# 操作系统部分总集篇:

## 线程：

### 基本定义:

- 轮换时间片的基本单位,进程的执行单元

### 线程的运行方式：

- 并行：多个线程同时进行
- 并发：多个线程交替执行

### 线程的三种状态:

- 新建
- 就绪
- 阻塞
- 运行
- 死亡

#### 状态的转换:

- 就绪--运行:获得CPU时间片
- 运行--就绪:时间片使用耗尽
- 运行--阻塞:等待IO操作
- 阻塞--运行:IO操作已经发生
- 就绪不能到达阻塞
- 阻塞不能到达运行

### 线程的组成部分:

#### 线程堆栈:

##### 线程栈:

- 用于存储临时局部变量
- Windows默认大小为1M  
- 线程栈是每个线程各自拥有的,对于一个线程,栈空间是私有的
- 销毁线程时,线程栈被销毁

##### 线程堆:

- 线程堆是所有线程共用的
- 销毁线程时,线程堆不销毁

#### 线程内核对象:

- 操作系统通过内核对象管理线程

##### 计数器:

- 用于计量操作系统何时回收此资源

- 初始值为2
- 线程退出减1,关闭句柄减1
- 当计数器为0时系统会销毁线程的所有资源

##### 信号:

- 默认无信号,退出变为有信号
- 是用于判断线程是否退出的标志

### 创建线程函数:

```
CreateThread()
```

- 使用此函数创建线程时,在线程函数中应仅使用WindowsAPI函数

- 如果使用了C/C++运行时库中函数会检测是否创建了内存块
  - 如果没有创建,系统会自动地创建一个内存块
  - 此时如果线程函数正常退出,且并没有销毁此内存块时,会引发内存泄漏
- 此函数创建的线程一般都是用户模式下的线程

```
Beginthread()
```

- 先创建内存块,在调用CreateThread()

```
AfxBeginthread()
```

- MFC库中调用的创建线程函数,底层调用的仍然是CreateThread()

```
pthread()
```

- 可以跨平台的线程函数,适用于Linux系统

### 线程的退出:

##### 线程退出的几种方式:

- 变量退出:
  - 退出时,将类成员中的bool类型的变量置为false
- 强制退出:
  - TerminatedThread函数
- 事件(内核对象)退出
  - 可以跨进程

### 线程的分类:

- 依照进程中分成的3块区域划分:
- 进程分为:用户模式区,内核模式区,空指针区;
- 也可按功能划分
  - UI线程
  - 工作线程

#### 用户模式线程:

- CreateThread()创建的线程:

- 这种线程被创建后操作系统是无法确认的的

- 通过使用**操作系统为此线程的进程分配的时间片**来进行工作
- 此时一个时间片是被多个线程共同使用的;
- 用户模式线程的多线程是通过提高多根线程的工作密集度来提高的工作效率

#### 内核模式线程:

- 操作系统行轮换时间片的线程
- 函数

#### 用户模式线程与内核模式线程之间的工作关系:

- 1:1
  - 一个内核模式进程对应一个用户模式进程
- n:1
  - n个用户模式对应一个内核模式
  - 线程轮换同一个时间片,通过提高工作密度提高工作效率
- m:n
  - Windows系统下使用的工作方式
  - 多个用户模式线程共用多个内核模式线程所得到的时间片

### 线程间通信方式:

#### 消息:

#### 全局变量:

- 同一进程内使用全局变量传输数据

#### socket:

#### 内核对象:

- 事件

- 互斥量

- 信号量
- 关键段(牵强)

#### 文件:

#### 文件映射(共享内存):

#### 管道:

#### 邮槽:

#### 剪贴板:

#### 动态链接库:

- 动态内存库在内存中存储一份
- 每多一个进/线程引用库时,共享库的引用计数增加,这样实现了多进程间的通信
  - 进程中进行工作的就是线程

### 线程同步

#### 原子访问

#### 内核对象

##### 互斥量:

- ###### 初始拥有权

##### 事件:

- 人工
- 自动

##### 信号量:

- 设定指定数量的信号量

#### 关键段:

- 直接阻塞:进入失败即阻塞
- 旋转锁:等待一会在进入,失败则返回
- 异步处理:试图进入,失败则寻找其他关键段

#### 内核对象与关键段的区别:

- 内核对象可以跨进程,关键段不能
- 内核对象更加安全灵活
  - 可任意设定阻塞时间
  - 当有一线程被杀死,对应线程的内核对象会被自动的回收,不会令其他线程仍处于阻塞的状态
- 关键段效率更高,内核对象效率更低
  - 关键段是用户模式下的线程同步
  - 内核对象是内核模式下的线程同步,切换需要时间

### 多线程模型与线程池:

#### 多线程模型:

- 线程随用随创建,用后即销毁
- 效率较低
- 不能自动的管理线程
- 在处理较复杂(消耗时间较长)的任务时可以选用

#### 线程池模型:

- 能够管理线程,按指定的任务进行工作
- 预先创建一些线程
- 使其处为睡眠或阻塞状态(不占用CPU),来任务即唤醒
- 不适用于较复杂的任务((消耗时间较长)),会占用较多资源

## 死锁:

- 多线程因竞争资源而产生的阻塞状态

# 库:

## 动态库与静态库的区别: 

## 进程：

- 以进程为单位分配内存资源
- 是程序的动态表现

### 创建进程:

- 操作系统的位数影响进程
  - 32位进程有4GB虚拟内存空间
  - 64位进程有16TB虚拟内存空间

### 进程的形态:(32位系统举例)

- 空指针模式:0~64k
  - 用于调试程序
- 用户模式:64kB~2GB
  - 进程的私有地址空间
- 内核模式:2G~4GB
  - 被所有进程共享的一块空间

#### 注意:

- 64位进程中
  - 用户模式:0~8T
  - 内核模式:8T~16T

### 进程的内存分配:

- 进程在实际运行时需要操作系统为为其分配一些空间,分为

#### 连续空间分配:

- 单一连续空间分配
  - 内存分为用户区(作业)与系统区 
- 固定分区分配
  - 
- 动态分区分配
  - 要多少分配多少
- 空间不足时要使用空间拼凑技术
  - 浪费时间,引入非连续空间分配存储方式

#### 非连续空间分配(重点)

- 页式管理
  - 一页的大小是512B~8KB之间
  - Windows默认是4KB大小
  - 为了提高CPU使用效率
- 段式管理
  - 为了提高用户使用效率
- 段页式管理

### 进程的作用：

- 可以提高程序的效率

### 进程间通信方式:

#### 消息:

#### socket:

#### 内核对象:

- 事件

- 互斥量

- 信号量
- 关键段(牵强)

#### 文件:

#### 文件映射(共享内存):

#### 管道:

#### 剪贴板:

#### 邮槽:

#### 动态链接库:

- 动态内存库在内存中存储一份
- 每多一个进/线程引用库时,共享库的引用计数增加,这样实现了多进程间的通信
  - 进程中进行工作的就是线程





线程栈作用：存储当前线程所需要资源
内核对象的作用：挂起计数器，信号
信号的作用：判断线程是否退出

现成的基本状态L就绪运行阻塞的转化
阻塞到就绪：等待的i哦操作已经发生
运行到阻塞：等待io操作
运行到就绪L时间片使用完了
线程间的通信方式：
socket
事件
信号量
关键段
消息
管道
全局队（共享内存）
动态库 ：dll
进程间通信：
dll-》静态库和动态库的区别：
动态库用于扩展性强的程序

线程并发问题：线程同步----原子访问（紧缩一个资源），
关键段，
事件，
信号量，
预处理
编译
汇编
链接
。。

操作系统通过哪种方式已分配内存空间：非连续内存分配空间方式：
页式

fifo
LRU最迟最近未使用

创建一个进程的时候曹祖系统会分配多少空间
32位4GB（寻址范围2的32次幂）虚拟地址空间，所有内核对象都存储与内核模式空间中
64位16TB 

线程同步，关键段直接阻塞，旋转锁，异步处理



生产者和消费者


线程池：多条线程诱惑创建线程

线程池的接口：
线程不是线程越多效率越高
注意销毁
并发问题由线程访问处理

多线程模型和多进程模型有什么区别
多进程相互之间
见状和安全，当某一线程破坏了共享资源


IO模型，
同步阻塞+多线程
单线程成立时：单线程阻塞（）

select模型：将需要查看的放入一个集合内，查看集合	默认64
异步选择
异步事件
想Windows发送事件

三种都是阻塞的模型

完成端口 ：主动投递一个内存通过共享内存的方式以共享内存