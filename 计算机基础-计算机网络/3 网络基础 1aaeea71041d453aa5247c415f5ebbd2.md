# 3.网络基础

# 网络基础

## 相关网络概念:

- 主机:
- Mac地址:每个电脑独有一个的地址标识
- 端口号:确定信息是发给谁的标识号
- 电缆和网线集线器（集线器,HUB现已不使用）
- 路由器:跨网段传输,主要网络层工作,IP协议

## 几种常用的网络模型

### OSI七层模型(自底向上)

1. 物理层
2. 数据链路层: 交换机工作原理 MAC地址
3. 网络层: 跨网段传输数据 确定目标主机 IP地址
4. 传输层: 确定目标进程 端口号
5. 会话层: 建立连接关系
6. 表示层: 进程中目标数据格式的转化
7. 应用层:

### TCP/IP四层模型(简化模型)及各层中常用的协议:

- OSI模型的一种实际应用优化模型,主要运用TCP协议与IP协议
1. 数据链路层(交换机通过MAC寻找电脑主机地址):
    - OSI中数据链路层与物理层的合并版本
    - ARP地址解析协议:通过IP地址确定MAC地址
    - RARP:通过MAC地址确定IP地址
2. 网络层(通过IP地址找到主机):
    - IP
    - ICMP:网际控制文本传输协议(ping)
    - IPC:路由信息协议
3. 传输层(通过端口号找到进程):
    - TCP
    - UDP
    - RUDP
4. 应用层:
    1. http(hyper text transfer protocol)超文本传输协议
    2. https 超文本传输加密协议
    3. DNS:(域名解析服务)
    4. ftp:广域网文件传输协议
    5. TFTP:局域网文件传输协议
    6. POP3:传输文件协议 注意:多个域名(网址)可以映射同一IP地址 ## 模型各层的工作原理:

### 数据链路层:

- 交换机:(ARP协议是数据链路层的主要协议)
    - 交换机接收到一个消息请求后,向整个局域网中广播
    - 局域网中的各个主机,将不属于自己应接受的信息过滤掉
    - 仅有目标地址的主机接收到了网络请求
    - 目标主机将自身MAC地址与对应IP地址发送回原发送方主机处
    - 以后每当发送方发送数据时,先检索IP-MAC的映射表中是否有对应目标地址

# 使用网络功能编程的基本流程:

1. 加载库:WSAStartup（版本号）
2. 创建套接字（与外界通信接口）
3. 绑定地址
4. 回复数据
5. 关闭套接字

网络编程中,先启动服务器,再启动客户端

# 端口号:

- 范围（无符号short类型）:0-65535
- 知名端口号（冲突率高,一般被占用）：0-1024
- 动态端口号：1025-5000
- 预留端口号：5000-65535
- 同一协议只能绑定一个端口号
- 一个进程可以绑定多个端口号

## 网络字节序（区别：大异小同）

- 大端模式：网络字节序的通讯均为大端通信
- 小端模式：大部分主机采用

### 大端小端数据转化:

对应端口号的16进制形式中从右向左数,每两位一组进行**组间倒序排列**;

1234(10)=04D2(16)==>D204(16)=(10)

# send函数,recv函数:

- send函数,recv函数在进程的用户空间中运行
- 创建套件字时在进程内核空间分配两种网络空间:
    - 发送缓冲区
    - 接收缓冲区
- 两进程通过网络发送消息时;
    - 由send to 传递至发送缓冲区
        - （此时数据传递受socket是否阻塞的影响）
    - 通过网络传递至另一进程的接收缓冲区中
    - 另一进程直接将数据从接收缓冲区中拷贝至recv（内核空间
    - 数据传递完成
- 发送缓冲区接收缓冲区的大小 获取socket缓冲区的大小

（win10&wi8 64KB win7:8kb）,大小可更改但有上限

- Sock的默认两种属性(阻塞和非阻塞)
    - 阻塞：
        - 直到拿到数据之后才返回
    - 非阻塞：
        - 等待一段时间之后直接返回
        - 不管有没有数据，没有数据是返回-1
    - 非阻塞属性更快，阻塞属性会一直等待
- send函数中
    - 阻塞:单次数据超过输入缓冲区大小放入失败,数据完整放入才返回
    - 非阻塞:
- recv函数中
    - 阻塞:接到数据后才返回
    - 非阻塞:不管是否接收数据都返回,根据返回结果确定是否有数据
- 调用ioctlsocket函数更改socket的属性

当发送缓冲区大于发送数据大小时，

客户端： 创建套接字的协议必须与服务器相同 客户端无需绑定（端口号？） 广播 ：分为两种 1）直接广播：向指定网段内广播（发送数据） example：192.168.3.155 a.数据可以跨路由器传输 2）有限广播：向局域网内任意网段发送数据 a.数据不能跨路由器（被路由器禁止） example：255.255.255.255 b.需要权限

UDP协议的特点 面向无连接：可以一对一，一对多的通信， 广播范围不同， 组播 数据报文：固定大小,不可拆分 传输效率高：有可能丢包，乱序 Send to将数据放入发送缓冲区 当数据被发送至网络 就在缓冲区内将数据删掉 无校验检查：乱序 网络波动：丢包

# TCP协议

## 服务器工作流程:

1. 加载库:WSAstartup（）
2. 雇佣服务员: socket（）
3. 找地方: bind（）
4. 宣传:listen（）
5. 接受客人,领进店里,并将客人交给服务员:accept()
6. 让服务员仅听客人说话（仅接收消息）:recv()
7. 服务员回复消息:send()
8. 服务员下班:closesocket()
9. 关店:WSACleanup(); ### 代码实现 2.创建SOCKET:

```
SOCKET socketlisten=socket(AF_NET,SOCKET_STREAM,IPPROTO_TCP);
if(socketlisten==INVAILD_SOCKET)
{
    WSACleanup();
    return -1;
}
    //AF_NET:表示IPv4地址族
    //SOCKET_STREAM:socket使用数据流方式传输数据
    //IPPROTO_TCP:socket基于TCP协议
    //INVAILD_SOCKET:表示socket创建失败,失败时直接关闭加载库,并返回错误信息;
```

## 客户端工作流程:

1. 加载库:WSAstartup（）
2. 创建顾客: socket（）
3. 找地方: connect()
4. 说出要求:send()
5. 等待服务员回复:recv()
6. 离开:closesocket()
7. 关店:WSACleanup();

面向通信的 TCP超时重传 序号用于校验 # TCP三次握手 1. 客户端发送:在吗 客户端切换状态为SYN SND 发送SYN=1,确认序号=X 2. 服务器回复:在 服务器切换状态为SYN RCVD 回复ACK=1 3. 客户端发送:收到 ## 相关术语: - SYN：请求连接 - ACK：收到回复 - PSH：推送数据 - RST：重置连接 - FIN：结束链接 - URG：紧急指针标志位（优先发送） Server：

## 三次握手可以改成2次吗(第二次握手时已经连接成功)?

不能,原因: - 第二次连接时,进入半连接状态,未完全链接; - 假设将三次握手改为2次, - 服务器返回的信息可能丢失 - Server第二次握手时尚未进入ESTABLISHED状态

#TCP流量控制:使用滑动窗口机制

TCP三次握手

粘包 Nagle 数据量达到最小范围才发送（46字节） 合并算法 等待粘包时 粘包可禁用 粘包原因很多 如何解决 怎么把粘住的包分开 1）前后加前缀后缀 发送端知道 再每个包中末尾加上特殊字符以 ②包大小，在包头加一个包的长度 ③固定包大小 ④连接方式：根据任务完成决定连接方式 短链接： 包在发送缓冲区粘住 每一个socket在内核空间都有一个自己的缓冲区 将三个小数据包分成三个socket来发 长连接：数据均由一个socket来发 滑动窗口是如何工作的 窗口是以对方接收数据能力为准（有多少空间能够存数据）

1比特流协议 每次发数据时只发送一比特 收到回复再发下一个 后退n协议 发送数据时如果中间出现丢包，回退至丢包位置重新传 选择重传协议 空间换取时间 需申请一个和原来空间大小相同的空间以判断丢了哪一个 确定后重传丢的那个

UDP，TCP区别 UDP 1.面向无连接（一对一，一对n，组播，广播（）） 2.数据报文（固定大小） 3.传输效率高，但会丢包，乱序 (1)当数据发送后原数据会在发送缓冲区中被删除 TCP 1.面向连接（三次握手，四次挥手） 2.数据流（任意拆分，粘包问题） 3.安全 (1)每个包里有讯号 4.重传 5.滑动窗口：以对方的窗口大小为准 6.拥塞控制（考虑整个网络的情况）

四次挥手 TCP:全双工通信 TIME_WAIT作用: 能够保证正常终止 允许老的重复分节在网络中消失

当执行关闭。。函数时是四次挥手的开始 shutdown(socketwaiter,SD_BOTH );

服务器可以接受n多个客户端 并完成通信0

数组可以存储数据会保存数据，不使用数组各socketwaiter均为局部变量用后及删除 create thread函数中的线程参数为传递值线程函数的参数 通过线程函数的参数来将主函数和线程函数进行连接 线程函数是用来实际干活的（每个线程都要干什么）