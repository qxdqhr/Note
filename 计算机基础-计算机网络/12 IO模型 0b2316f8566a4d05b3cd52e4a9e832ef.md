# 12.IO模型

# 最简单的网络IO操作方法—同步阻塞+多线程模式:

- 当服务器接收到Socket时
    - 在Accept函数中
- 服务器都要为每一个Socket创建一个线程
    - 在Accept函数中创建线程去接受数据(调用recv函数进行阻塞监听)

## 此模式的缺点:

1. 能够监听的Socket是有限的,最大只能监听
2. 较为浪费资源,一个线程只监听一个Socket

# 改进:同步非阻塞模式

1. 服务器中一条线程可监听多个Socket
    - 所有SocketWaiter公用一条线程
    - recv函数在接受等待数据时是阻塞的,必须将这层阻塞去除,否则无法达到此改进目的
        - 需要将Socket置为非阻塞模式
            - Socket默认设定为阻塞态
            - 使用ioctlsocket函数更改阻塞/非阻塞态
2. 接收数据函数(Accept函数)
    1. 每接收到一个Socket时,都
3. 在服务器中的单一Socket类成员更换为Socket链表,使此成员能够处理多个Socket
4. 利用此成员将原来创建多个线程接受Socket连接的工作更换为一条线程处理多个Socket连接

单线程

同步阻塞模式:

- 用户模式一直阻塞等待数据,直到接收到数据在返回

非阻塞模式:

- 用户模式配置多个recv函数
- 3个线程不断的调用recv函数判断是否接收到数据

# 使用非阻塞方式来处理多个套接字

## 更改SocketWaiter为非阻塞方式

接受数据的线程工作函数中

遍历

# IO模型

## Select模型:

### 目的:

- 单线程处理多个套接字

### 方法:

1. 将需要查看的Socket放入一集合内,并交给集合交给Select管理
2. 在内核中观察一段时间,可以设定每隔n分钟返回一次数据
3. 将发生网络事件的Socket留在原集合内
4. 校验

### 注意:

- 无取数据权限,仅有发送通知权限
- 若接收到数据,单一线程切换回用户模式

### 工作过程:

1. 定义集合 fd_set
    - 类成员定义
2. 清空集合 FD_ZERO()
    - 构造化函数呢调用此函数进行初始化
3. 将Socket加入集合内 FD_SET()
    - 线程工作函数中调用此函数,将SocketWaiter加入集合中
    - 可以将Socket加入链表中管理(此步骤可省略)
4. 将集合交给Select管理
5. 一段时间过后
6. 校验 FD_ISSET();
7. 重复3~5步骤

### 代码流程:

### 测试:

单个

可以重新定义Select的大小

11.6.2019 如果有人来链接监听窗口

对于刚刚和客户端连接的窗口，原来就阻塞 只要脸上九江listen交给IOCP以管理

管理了一个socket队列 所有工作都交给了IOCP

线程采用后进先出

完成键

消息（附加参数） 其他信息装在附加参数中

创建WAITER 设定一个函数

。。// Acceptex函数 监听socket 接收到的socket 接收连接成功所发送的第一个数据块 数据快播放肥的大小 本地地址长度 远程的地址信息 返回用于接收的字节传送总数 OVELAPPED 结构体 成员事件，完成端口发现时间有信号将会返回一个 。。。、 将socket的信息返回//？ TCPNEt.h中

使用此结构体中的时间

设定枚举v变量

接到的数据放在所定义的一段数据缓冲区

一辆接上如果socket中有事件 通过此种方式以共享内存 事件有信号是

创建的是win32控制台应用程序 使用。。。 库是。。。

链接成功立即返回，设定值为0； 本地信息的长度

将waiter交给完成端口以管理 解决阻塞问题：

POSTPECV（投递出去的是哪一块内存的空间socket*） 共享内存

# 异步事件

工作机制:

先向Windows注册请求

当发生网络请求时

WSAEvent函数

套接字

事件

WSACreateEvent函数,创建人工的无信号函数

创建线程

线程工作函数中等待事件

一旦事件置为有信号,说明接收到Socket请求

使用Socket接收Socket

# 完成端口模型

异步事件与Select模型都是来客人是发送通知,

都未达到同时性

都是单线程模型

在增大并发访问量时,如何才能做成同时处理连接请求

应用多线程,即使用线程池

预先创建线程,令他们一些SockWaiter