\1. 协议:protocol.



 

  作用: 

  1). 专门用来声明一大堆方法. (不能声明属性,也不能实现方法,只能用来写方法的声明).

  2). 只要某个类遵守了这个协议.就相当于拥有这个协议中的所有的方法声明.而不用自己去定义.



 

 

   

 \2. 协议的声明.

 

   @protocol 协议名称 <NSObject>



   方法的声明;

 

   @end

 

 

   新建1个协议的方式. NewFile OC-File - protocol

   协议的文件名: .h 并且只有1个.h文件.

 

 

   在协议中,只能用来声明方法,协议的作用:就是专门用来写方法声明的.

 

   

 

 

 \3. 类遵守协议.

 

 

   协议就是用来写方法声明的,就是用来被类遵守的.

 

   如果想要让1个类,拥有协议中定义的所有的方法声明.那么就让这个类遵守这个协议.

   类只要遵守1个协议,那么这个类就拥有了这些协议中定义的所有的方法的声明了.

 

 

   @interface 类名 : 父类名 <协议名称>

 

   @end

 

   : 表示继承.

   <> 表示遵守的协议.

 

   当1个类,遵守了1个协议,那么就相当于这个类拥有了协议中定义的所有的方法的声明.

   这个类只是拥有了这个协议中的方法的声明而已. 没有实现.所以 这个类,就应该实现协议中的方法.

 

 

   如果类不实现协议中的方法,其实也不会报错.编译器只是会报警告.

   但是当创建对象,来调用这个没有实现的协议中的方法的时候,就会报错.

 

 

 

 

 \4. 类是单继承. 但是协议可以多遵守.

 

   1个类只能有1个父类

   但是1个类可以同时遵守多个个协议.

 

   @interface 类名 : 父类名 <协议名称1,协议名称2......>

 

   @end

 

   当1个类遵守了多个协议之后,就相当于这个类拥有了所有协议中定义的方法的声明.

   那么这个类,就应该实现所有协议中的方法.

​     

   如果不实现,其实也不会报错.编译器只是会报警告.

   但是当创建对象,来调用这个没有实现的协议中的方法的时候,就会报错.

 

  \--------

   当1个类遵守了某个协议.就相当于这个类拥有了这份协议中的所有的方法的声明.

   但是仅仅只是有方法的声明而已,没有是实现,要类自己去实现.

 

   如果类不实现.编译器不会报错. 只是给1个警告.

   当我们创建对象,如果不调用这个协议方法,就不会报错.

   如果要调用这个协议方法,那就会报错.

 

 

 

 

 

 

 \5. @required 与 @optional

 

   当1个类遵守了1份协议.这个类就拥有这个协议中的所有的方法声明 仅仅是只有声明而已.还要自己实现.

   如果不实现呢?也不会报错 只是给1个警告.

 

 

   @required 与 @optional这两个修饰符是专门用来修饰协议中的方法的.

 

   在协议中,如果方法的声明被@required修饰,那么遵守这个协议的类必须要实现这个方法,否则编译器会发出警告.

   在协议中,如果方法的声明被@optional修饰,那么遵守这个协议的类如果不实现这个方法.编译器也不会报警告.

 

   其实,无论是@required还是@optional你都可以不实现. 编译器是不会报错的. 仍然可以编译 运行.

   唯一的区别就是: 当遵守协议的类不实现协议中的方法的时候,@required会给1个警告. @optional警告都木有.

 

 

 

   

   这两个关键字的主要作用:在于程序员沟通,告诉遵守协议的类 哪些方法是必须要实现的,

 

 因为这些方法我会调用.

 

   默认的是@required

 

 



 

 

 

 \6. 协议可以从另外1个协议继承,并且可以多继承.



   协议可以继承另外1个协议. A 协议 继承了 B协议. 那么A协议中不仅有自己的方法的声明,还有B协议中的方法的声明.

   如果有1个类遵守了A协议，那么这个类就拥有了, A、B协议中的所有的方法的声明.

 

   协议之间继承的语法格式

   @protocol A协议名称 <B协议名称>

   

   @end

 

   代表A协议继承自B协议, A协议中既有自己的方法声明,也有B协议中的方法声明.

 

 

 

 

   NSOBject: 这是1个类. 是所有的OC类的基类. 这个类是苹果早就定义好得.

   NSOBject: 这也是1个协议. 也是苹果早就定义好得. 这个协议被NSObject类遵守.

​        所以,所有的OC对象都拥有这个协议中的所有的方法.

​        这个协议我们也叫做基协议.

 

   写协议的规范: 任何1个协议,必须要间接的或者直接的去遵守这个NSObject基协议.

 

   协议的名称可以和类的名称相同:



 

 

 \7. @protocol类型限制.

   

  1). 要求某个指针保存的是遵守指定协议的对象.   

 

​    NSObject<myProtocol> *obj;

 

​    id<myProtocol> *obj;

 

 

  2). 要求某个指针变量保存的是继承了某个类,并遵守了指定协议的对象.

 

 

 

  3). 属性案例: 男孩子的女朋友.

 

 

  4). 为什么要求对象遵守协议?

 

​    因为我要调用对象的这个方法 你只有遵守了这个协议才有这个方法.

 

  5). 协议与继承,

 

​    超人 鸟 飞机 装X飞.

​     

 

 

 

 8.案例: 婴儿饿了要哭 困了要睡 保姆开照顾. 老师也能当保姆.

 

 \1. 协议与协议之间可以相互继承.

 

   1). 继承的语法:

​      

​     @protocol 协议名称 <父协议名称>

 

​     @end

 

   2). 效果:

​     子协议中不仅有自己的方法的声明,还有父协议中的所有的方法的声明.

​     如果1个类遵守了某份协议,那么这个类就拥有这个协议和这个协议的父协议中的所有的方法声明.

 

 

 \2. 介绍1个东西. NSObject

   

   在Foundation框架中,有1个类 叫做NSObject 是所有OC类的基类.

   在Foundation框架中,有1个协议.叫做NSObject.

 

   NSObject协议被NSObject类遵守.所以,NSObject协议中的所有的方法 全部的OC类都拥有了.

   这么说,所有的OC类都遵守了NSObject协议. NSObject协议叫做基协议.

 

   类的名称可以和协议的名称一致.

 

 

 \3. 写协议的规范:

   

   要求所有的协议都必须直接的或者间接的从NSObject基协议继承.

 

 

 

​      \1. 请声明1个指针.这个指针可以指向任意的对象,但是要求指向的对象要遵守指定的协议.

   如果不遵守 最起码要报1个警告.

 

   要求声明1个指针 指向1个遵守了学习协议的对象, 否则最起码要给哥哥1个警告.

 

   NSObject<协议名称> *指针名;

   这个时候,这个指针可以指向遵守了指定协议的任意对象. 否则就会报1个警告.

   NSObject<StudyProtocol> *obj = [Student new];

 

 

   当然了完全也可以使用id指针.

   id<协议名称> 指针名;

   id<StudyProtocol> id1 = [Student new];

 

 

  \2. 声明1个指针变量,要求这个指针变量指向的对象必须遵守多个协议.



   NSObject<StudyProtocol,SBProtocol> *obj1 = [Student new];

 

   id<StudyProtocol,SBProtocol> obj1 = [Student new];

 

 

  \3. 定义1个指针,指向遵守了学习协议的学生对象.

 

 

  \4. WHY?

 

   1). 遵守了某个协议的类,就相当于这个类拥有了这个协议所定义的行为.

 

   2). 因为我要调用这个对象中的协议方法.

​     只有类遵守了协议,这个类中一定才会有协议方法.

 