# Linux 进程间关系

# 进程间关系分为：

- 父子进程关系（Linux 系统的强亲缘关系）
- 进程组关系
- 进程会话关系

# 父子进程关系

僵尸进程：Zombile process 

产生原因：子进程返回时父进程没有读取到子进程的返回值

并未回收（内存泄漏）

孤儿进程： 

产生原因：父进程先于子进程终止，子进程失去控制 ,可能导致系统崩溃

孤儿进程仅挂名于托管进程,所以孤儿进程在某些环境下可能更危险 

Linux中存在一个托管进程（孤儿院） 当某子进程的父进程被终止，该子进程由托管进程以托管 （仅当子进程死亡时（结束工作周期（也可能不结束））托管进程回收子进程， 但托管进程不管理子进程任务，此时若子进程对系统有危害，危害会持续

 僵尸进程易于发现并处理 孤儿产生并不会提示不易发现 

避免孤儿问题的方案： 让父进程足够健壮，减少异常结束的几率 只要父进程退出，一定有消息通知（进程结束反馈），此时就应考虑孤儿进程 也可在父进程结束后杀死子进程（不适用于守护进程（精灵进程）） 

守护进程/精灵进程：人为制造的孤儿进程（周期工作或持续工作）

 1）寿命长，工作周期长（随系统持续，开机自动启动，关机关闭） 普通进程的寿命随

 2）让其他人更加健壮，持续守护保证主程序核心稳定，正常运行

如何产生孤儿进程 进程间 某个服务，多个服务添加后

在Ubuntu14中 1号进程： UI进程终止：注销 可视化进程终止 ps ajx 查看进程关系 ps aux 查看进程信息

僵尸进程的危害：PCB残留使得 内存泄漏，少创建一些进程

孤儿进程的危害： 一些特定情况下，孤儿进程的危害可能一直持续下去 eg；子进程不断申请资源，父进程使用资源，父进程向子进程发送通知结束申请资源 父进程发生异常终止后，子进程会源源不断申请空间，子进程失去了终止申请的信号， 最终可能会导致系统崩溃（申请资源耗尽） 孤儿进程的处理： 孤儿院，托管进程：当出现孤儿进程时，将孤儿进程交给托管进程管控 托管进程不会与孤儿进程有任何交互，只当孤儿进程结束时，托管进程将孤儿进程回收

组关系：group

进程组概念 组一定有组长， 组什么时候销毁： 与组长是否销毁无关，当最后一个进程退出时，终止或转移到其他组，该组成员为0时，内核会销毁该组 进程组组长 组名在进程销毁会之前无法更改 转移组：setpgid（））—设置组id—组长也可以转移，转移到其他现有组 组id：组长的id与组id一直，此进程为组长

一个组中可以没有一个组长

# 进程组关系

- 进程组:由一个组长进程和N个组员构成
- 组长进程的确定： 组长进程的pid=进程组id（gid）

进程组与进程间亲缘关系 进程组概念与进程间亲缘关系没有必然联系

```
多个进程的pid连续的几个进程只能证明其拥有亲缘关系，
不能依据进程pid来判断进程间关系

1)A->B->C->D    2)A->B A->C A->D
1)和2)中ABCD的pid均连续

进程组中子进程成为组长，子进程的原亲缘关系不变
```

进程组生命周期： 组长创建和申请进程组（组内可以无成员） 进程组内无任何进程时，内核回收释放该组资源 （组内进程可能全部结束或转移至其他组中） 组是否销毁与组长进程无必然联系

- 查看进程关系命令： ps ajx
- 查看进程信息命令： ps aux setpgid（）

# 进程会话关系：

会话关系： 关闭终端时，为什么需要杀死进程 sesion会话

会话发起进程 特点pid==pqid==sid ‘终端常常是会话发起者 会话的参与者进程在会话发起者结束后要被杀死 若想不被杀死就要脱离终端 如何脱离终端：自己发起一个会话 如何创建新会话（pid） getsid（）获取当前会话 setsid（）设置当前会话 setpgid（创建新组） 想要窗机哪一个新会话不能是一个组长，只能是一个组员进程（通过使用setid创建一个新会话）（组员脱离了控制终端）

人为的守护进程的雏形

守护进程

数据重定向

chdir：改变工作路径 根目录下的temp文件夹有创建文件的权限 umask函数修改权限

获取当前时间 time。h 19xx年到现今的秒数 

进程的回收方式 Waitpid

此时创建了子进程的父进程阻塞于回收子进程资源（等待所有子进程死亡）,不能干自己原有的工作

采用阻塞wait回收方案会导致，父进程无法完成自身的核心工作 

解决方法：

将阻塞wait回收方案设置成waitpid非阻塞回收

Waitpid（pid，大于0仅回收一个 0 回收当前进程的同组所有子进程 -1 只要是子进程就回收，无论是否同组 <-1 回收当前组中的所有子进程（指定好了某一组数字为指定的组id） ）； 

返回值pid_t类型

大于0回收成功：表示回收成功返回回收成功的pid 

0非阻塞返回：表示他在但未结束（子进程运行中），不能回收（轮巡回收）

-1没有可回收子进程：一个儿子都没有，调用失败（没有子进程回收个锤）

 Option WNOHANG 非阻塞轮询代码

仍不是最终解决方案（无奈之举） 轮询回收可以穿插执行某些工作 父亲干活，同时每隔一段时间问问子进程死没死 父亲工作效率很低（被询问所占用）给核心工作的资源过少

正常思路：（异步思路）需要线程核心及信号知识 父子均100%投入工作 当儿子死了 父亲收到消息，停下工作 处理子进程 之后继续正常工作