# 6.线程NPTL

Linux使用的是第三方的NPTL线程库 NPTL2.7版本 完整库名：libpthread.so 真实库名：pthread

编译时要加库名 Gcc a.c -lpthread -o app

线程创建：pthread_create（phtread_t*tid,传出线程id NULL,线程属性 Void* （*threa_job）（void*）线程工作函数指针） Void*线程工作函数参数 ）

进程死了，线程一定死 主控线程先不要杀死

和

在此函数中为同一id创建线程函数创建中的tid为传出id Self函数中为刚刚创建的线程，获取的id与前者相同

开发操作系统一般都是使用第三方的线程库（win，mac，linux） 编译时要加库名 Gcc a.c -lpthread -o app

线程id时16进制数 pthread_self(); 线程id获取函数

线程中退出函数 Exit（）导致进程直接终止 此函数在多线程开发时一般不用， 只在批量销毁线程时用 return （） 主控线程 普通函数return表函数结束返回 主函数return 表进程直接终止（主函数中，与exit相同，）

普通线程退出：pthread_exit（） return 主控线程退出：pthread_exit() 进程退出：exit（） pthread_cancel(pthread_t tid) 一个线程取消另一线程（谁都可以使用只要有线程id，且线程正在运行，就能退出） （子可结束主控，主控也可结束子）

线程回收 pthread_exit（）退出码-1 return 退出码-2

白色高光表线程退出码

检测退出码 三种退出方式

主控线程

创建即开始工作，工作后就回收

显示退出码reval的值如何操作？ 1）直接强转（√） 2）转换为int*型在间接引用

进程1返回的是被强转的1为常量，不是地址，对常量间接引用会报错

最后return 0 若虚拟机为64位系统应使用long int型

回收线程退出码时，只有线程被cancel取消是，才会收-1，-1这个退出码保留不用 返回-1是被cancel掉的（默认） 项目开发文档中有退出码，可根据退出码来区分其中的退出原因

线程的终止止状态 JOBLE回收态 DETACH 分离态：线程结束内核自动回收线程资源 Pthread detach（线程id）函数：将谁设置成分离态的函数 JOBLE回收态和DETACH 分离态是互斥的 有一种状态先进入另一种状态会失败 对分离态线程进行回收，pthread_join会调用失败 对处于回收阶段的线程，设置pthread_detach分离，会设置失败 线程结束以前由自己回收， 设置分离态 好处：主控线程不用设置退出，内核回收，减轻主控线程工作负担， 缺点，无法获得线程的退出码，线程由内核销毁，

为了能让detach 能得到时间片让他睡觉

一些函数的错误处理方式 Strerror（）函数 给他错误码，他返回错误信息

主控线程获取普通线程id 普通线程如何获取主控线程id 传参

头文件

互斥的调用会失败，但程序不会报错

写项目：客户端win端 服务器Linux端（两端交互）

C++一半面向对象，一半面向过程 面向过程：造房子要一个砖一个砖的堆 面向对象：直接建房子，不用在意房子的具体过程直接调用 Pthread并不是系统函数 用户编译 严格编译：定义一个变量不使用都会报错 严格编译器不包含头文件一定会报错

程序中输出一句话，但不能包含main函数 main函数：主控制流程 若干个。c生成。O Main函数生成一个_start文件 最后一定要写一个exit（） 负责释放 创建不消毁会段错误

一个编译中的选项可以解决

禁用系统默认的_start函数 即可成功 作用：隐藏主函数接口 将start也隐藏掉

中文宽字节

主控函数的隐藏 不使用系统函数，使用。。。 WINDOWs改变程序入口 开源的传染性 借鉴别人的 写了99%借鉴了1%就被迫开源