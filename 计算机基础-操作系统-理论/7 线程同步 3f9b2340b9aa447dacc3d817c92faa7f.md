# 7.线程同步

Linux的线程同步（线程安全：合理使用全局资源以保证资源保护和线程协同） 用线程同步技术来保证线程安全 1）大量，，， 2）合理使用是多线程工作更严谨

多线程开发是比较常见的应用开发模型（并发程序）

线程分为： 用户级线程： 不会分配过多时间片，按照进程分配时间片 多进程快的原因：时间片获得的概率会变大 不能通过使用很多现成的方法来增加获得时间片的概率 不会被划分为分配时间片的单位，按照进程分配时间片 内核级线程： 在内核中可能按照进城来分配时间片 可以提高CPU中时间片的获取 按照内核级线程分配，可以获得更多时间片

制作高并发程序时，内核级线程快于用户级线程 但用户级线程也可以提高程序运行效率 等待阻塞睡眠消耗时间 用户级时间片分配密集度高 会提升执行效率

多线程的优点不仅有更多的时间片可以分配 还能使程序内部工作更为紧凑，加快程序执行速度

线程安全：多线程开发一定绕不过共享数据 共享数据有利有弊 利：方便工作 弊：数据损坏

管道，共享内存段，消息队列

线程安全：保护全局资源：全局变量，静态变量 多线程访问全局资源（互斥访问）—-使用系统提供的锁技术 我用的时候你别用，你用的时候我不用，同时用就会出错

出错： 数据异常（结果不对）（√） 数据损坏（结果损坏）（×）

有一个线程白干活：没有效果 实际操作：内存中放入寄存器中，寄存器中计算，从寄存器中取出 多线程访问全局资源可能导致结果异常，因为计算机的数据访问流程 两个线程如果同时访问某数据 可能导致某线程执行操作失效 （编译优化，系统默认开启） 即，两线程造成了无意义的开销

所以要使用互斥访问避免数据异常 方案： 1）互斥锁：（临界区的创建，临界区中的工作访问互斥） 仅有一个门的卫生间（经典例子） 尝试进入 关门上锁 开始工作 出门上锁 上锁和解锁之间会创建一个临界区 当一条进程工作时，其他进程在外面等着（被挂起等待，下一个给谁不确定，由CPU的分配方案决定） 惊群问题：未能进入工作的线程的唤醒再挂起是没有意义的，产生大量无意义的开销 如何解决：不让线程去抢夺，由内核内定 Linux下的互斥锁被优化：添加了一个等待队列 只要上了锁，就会被内核放入等待队列 在等待队列中，唤醒标记是随机发送给队列中的任意线程，仅唤醒一条线程（线程收到唤醒标记，被内核唤醒，使用锁）

惊群问题在其他环境下的解决：：添加类似于可充当互斥锁的实现

实现： pthread_mutex_init（）函数： 参数： 锁的地址， 锁属性（空为默认属性）

pthread_mutex_destroy(pthread_mutex_t * lock) 锁的属性 pthread_mutex_lock()阻塞获取锁

更灵活： pthread_mutex_trylock()非阻塞获取锁（类似于定时阻塞） pthread_mutex_timeout()定时阻塞获取锁

上锁 pthread_mutex_unlock() 解锁

多线程的数据处理逻辑 所只有一把 多份线程只定义一把锁

缺点： 开销大， 效率较低：一个线程A在占用锁资源的时候，线程B会一直等待

止呕全局资源，断陷车公共性啊，完整的所得 xxxxung

2）自旋锁 类似于互斥锁，但是，自旋锁线程不会挂起，若存在可用资源，第一时间获取资源使用，自选申请会导致资源一场

2）关键段

3）读写锁：读时共享，写时独占 读要加锁：为避免读的时候没有人去写数据 保证数据是实时的 写要加锁

有几个线程就有几个读锁 这些读锁都可以访问全局资源 读锁的申请有数量限制 读写不能同时进行，若同时进行读操作无法判断该读取那个数据 使用时不一定必须读写锁同时使用 线程读写操作互斥 读写锁的使用

usleep tid

让多个线程可以同时访问系统全局资源 4）进程锁：两进程同时访问同一全局资源也需要锁

线程同步：协调工作 线程能够协同配合工作（包含互斥和协同） 锁：资源访问互斥，保护多线程访问数据的稳定

信号量，条件变量：多线程协同工作（配合和调度，线程挂起交替） 线程都是挂起在cd上 线程挂起在那个条件变量上 函数：pthread_cond_wait（&cd）挂起当前线程 pthread_cond_signal（&cd）唤醒一个挂起在某个条件变量上的线程当前线程 pthread_cond_broadcast（&cd）唤醒一个挂起在某个条件变量上的线程当前线程 理论上几个条件，有几个条件变量

初始化锁 默认所属性为线程锁 可以修改县城所谓进程 定义一个互斥锁变量 定义一个所属型变量

，—

如何让两个进程拥有一个共享资源

文件锁： struct Flock 文件锁属性的结构体 文件锁用于处理大数据文件 flock结构体 type 决定。。。操作 whence 所文件的偏移量 start 相对偏移量（相对与绝对位置）绝对偏移已经能够实现所著文件的一部分 要锁100M文件，但要将此文件分段处理20一段相对锁住。 len 加锁长度（只有要对一个文件的不同的段上所即可） pid 当前文件操作的id号

小实例 支持用户传入参数 设定了结构体的几项 fcntrl函数锁住文件 上了写锁之后其他人使用文件时会提示被占用（文件安全。。。） 更改所结构体中type成员—-解锁 再次调用fcntrl函数

自旋锁：和互斥锁是兄弟关系 互斥锁的所有内容，自旋锁都适用 和互斥锁的区别 默认。。。等待 自旋锁不等待 不停的自选直到获取资源为止

优点：如果这个锁被释放自旋锁能更快的获取资源（第一时间） 缺点：开销大（一直在自旋）

项目需求决定使用哪种 宁可牺牲资源也要节约时间的快速获取资源——自旋锁 只要能获取资源就可以，但要减少系统开销–互斥

上锁开销很大，不停的占用内核资源 挂起等待消耗很多时间

无锁编程，有锁编程

死锁：卫生间 一个人进入卫生间就不再出来，在外的线程一直等待 产生了挂起和阻塞，但并未释放 案例： A线程使用A锁访问A资源 B线程使用B锁访问B资源 多线程开发时的一个普遍问题：线程多，资源少 原因：使用对方的资源时可能会产生错误（现成的相互等待（永久））

死锁检测后死锁处理

死锁处理（外力：杀死其中一个）就可以继续运行 处理后还要将被杀死的线程复活，反复杀死反复复活会浪费大量无用开销（线程的创建与杀死） 死锁不应着重于处理死锁而应着重于死锁预防

死锁产生原因：线程很多，资源很少（常见开发中的问题）

哲学家就餐问题（线程同步经典问题） {

有一个餐桌，围了5个哲学家，要进餐，每个人面前都一盘菜，5份，但每一个人都需要餐具（筷子）很少5只筷子 哲学家只有两种工作且思考和进食是随机的 吃饭：一次从左至右拿取餐具，餐具满足条件，则进食 思考：放弃所有餐具，什么也不干 问题：是否会产生死锁问题 会产生死锁：哲学家同时进餐，相互等待相邻的资源，产生永久地等待 解决方案：礼貌策略： 哲学家拿起餐具时，判断是否可以进餐，可以进餐则进餐，否则放弃所持有的餐具 并非完美策略，引发活锁问题（同时拿起，同时放下，逻辑问题，，无法使用资源）

解决方案2：权重系数方案 每个哲学家分级权限， 普通哲学家 超级哲学家：会强制剥夺旁边人的餐具 高级权限者的数量不应过多 其他的隐患：只有高级 权限者在吃饭，其他人都吃不上，还是不能合理的分配资源

两个人同时吃： 服务者：哲学家问题的完美解决，现有基础上添加的第三方

第三方：多态产生的中间件 服务者：哲学家定义为自私的，指著重于餐桌上的餐具 服务者记录了所有哲学家的状态（检测所有数据的使用情况，控制资源的申请） 哲学家吃之前询问服务者是否可以吃

银行家算法：银行：盈利为主 对自身资源进行管控 评估风险要资源时评估风险，可能产生死锁，将你移至等待队列

死锁检测：=====》有向图 将线程作为点 将申请资源的方向作为边（线程资源的申请关系） 拓扑遍历：检测有向图中是否有环、

死锁的处理的根本：外力杀死线程 预防不一定能杜绝死锁的发生

模拟实现死锁检测和处理方案