# 4.线程同步_互斥量

## 互斥量：

### 互斥量的用法：

1. 互斥量是**内核模式**下的线程同步，**可跨进程操作**
2. 互斥量需要通过句柄来进行操作 HANDLE m_Mutex；
3. 创建互斥量：调用创建互斥量函数，将句柄初始化为互斥量（构造函数）
    
    ```
    HANDLE CreateMutex（
        NULL，安全属性
        TRUE，初始拥有权参数，TRUE,谁调用谁能先使用;FALSE,所有线程公平竞争
        NULL，互斥量名（跨进程使用，单进程不用）
        ）；
    ```
    
4. 等待互斥量信号（锁定线程同步代码段）：等待互斥量信号，收到信号则开始工作 WaitForSingle（互斥量句柄，阻塞的时间（INFINITE））；
5. 释放互斥量：解锁线程同步代码段 ReleaseMutex（互斥量句柄）；
    - 某个取得互斥量的线程的工作结束后要将互斥量释放，使其他线程能够工作。
    - 注意：释放互斥量时，被锁定的代码段可能不止一个出口（if嵌套产生），需多次释放。
6. 关闭互斥量： closehandle（互斥量句柄）；
    - 判断句柄是否存在，关闭互斥量句柄，句柄附为空，一般在关闭消息函数中实现 ### 互斥量的初始拥有权:
- CreateMutex的初始拥有权由函数参数决定:
    - 参数为TRUE时，调用函数的线程**拥有互斥量的初始拥有权**。
    - 参数为FALSE时，调用函数的线程**无互斥量的初始拥有权**。
- 使用互斥量时,一般由主线程调用创建互斥量函数,
- 初始拥有权参数的不同决定了主线程是否拥有初始拥有权。
    - 若主线程**无初始拥有权**，其他线程能够获得初始拥有权，可以使用互斥量开始工作。
    - 若主线程**拥有初始拥有权**，其他线程无初始拥有权，不能开始工作；
- 若要使其他线程能够工作，主线程创建互斥量后应立即释放。

### 互斥量与其他线程同步方式的转化：与其他线程同步方式功能相同

### 关键段的直接阻塞：一直等待直到接收到信号

```
    WaitForSingle（互斥量句柄，INFINITE）
```

### 关键段的异步的写法：试图进入正在被使用的房间，发现有人，离开

```
    if（WaitForSingle（互斥量句柄，0）==WAIT_TIMEOUT）
        continue；
```

### 关键段的旋转锁+异步的写法：

```
试图进入正在被使用的房间，发现有人，等待一段时间，仍无法进入，离开
    if（WaitForSingle（互斥量句柄，100）==WAIT_TIMEOUT）
        continue；
由此可以得出：使用互斥量时，比关键段更加灵活，可以任意设置阻塞时间
```

### 关于跨进程使用互斥量：

互斥量跨进程操作时，在其它进程中调用打开互斥量函数会使用互斥量的名字（单进程无需设定）

调用OpenMutex函数;

### 互斥量的工作流程总结：

1. 许多员工（多条线程）同时抢一把钥匙（互斥量）
2. 谁抢到钥匙（互斥量），谁就能开门(接收到互斥量的信号);
3. 打开门此线程就能进到屋子里开始工作(执行线程同步代码段);
4. 工作结束后，此线程应将钥匙抛出(互斥量释放)，并离开房间(关闭互斥量句柄)，供以其他线程使用。

### 互斥量与关键段的区别：

### 能否跨进程：

互斥量（√）；关键段（×）；

### 安全，灵活性：

互斥量更加安全灵活：可以任意设置阻塞时间；

### 执行效率：

- 关键段使用效率更高
- 原因：
    - 关键段为用户模式下的线程同步，不需要切换状态
    - 互斥量要切换状态（用户空间->内核空间->用户空间）降低效率