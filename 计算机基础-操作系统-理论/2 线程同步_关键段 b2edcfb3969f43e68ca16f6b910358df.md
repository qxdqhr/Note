# 2.线程同步_关键段

# 关键段（临界区）

## 工作原理:

将关键段锁住的代码段以一个卫生间的形式表示; 每一条线程走到进入关键段函数(EnterCriticalSection())时， 先观察关键段中此时是否有线程正在运行同时只允许一个线程访问一个代码段

是一个同一进程中的

## 实现关键段的三种方式:

1. 直接阻塞
    1. 试图进入关键段
    2. 如果进不去直接离开
2. 旋转锁
    1. 试图进入关键段
    2. 设定等待时间
    3. 若超出等待时间离开
3. 异步处理TryEnterCriticalSection
    1. 试图进入关键段
    2. 如果进不去,返回
    3. 如果进去了,返回

## 关键段的具体使用:

### 关键段的定义以及初始化:

1. 类成员中定义一个结构体CRITICAL_SECTION类型的关键段成员变量
2. 构造函数中调用关键段的初始化函数:
    1. InitializeCriticalSection(关键段变量地址) ### 关键段的使用:
3. 确定关键段要锁住的代码段
4. 在锁住的代码段之前调用进入关键段函数
    1. EnterCriticalSection(关键段变量的地址);
5. 在锁住的代码段之后调用离开关键段函数
    1. LeaveCriticalSection(关键段变量的地址); ### 关键段的销毁删除:
6. 在本类中添加退出消息:
    1. 类视图–>属性–>退出消息函数(OnClose)
    2. 在ONClOSE(销毁消息)函数中调用销毁关键段函数
        1. DeleteCriticalSection(关键段变量地址)

## 应用于卖票问题中:

直接将单一线程的全部工作流程代码放入关键段中;即:

```
    EnterCriticalSection(&m_CS);
        pthis->Tickets--;
        str.Format(_T("第%d号窗口卖出了第%d张票"),GetCurrentThreadId(),pthis->Tickets);
    LeaveCriticalSection(&m_CS);
```

此时即可保证不在卖出重复的票;

## 注意:

- 关键段中加了sleep会错误(重要)
    - 锁中不要延时，及其影响效率

锁上的代码段比作卫生间 两线程一张票 票为0时就停止买，判断应放在关键段中

厕所中的人从窗户走，没走门，其他人仍等在门外 在他从窗户跳出去之前开门

此时即可保证不在卖出重复的票;

## 出现问题:

卖票时会出现负数票;

有人进来，变为有人，运行态变为阻塞态 此时1出来，2变为运行态

内核空间与用户空间： 进程中的三块空间（32位下系统） 1）0-64k空指针 2）64k-2GB用户空间（关键段的线程同步） 3）2GB到4GB内核空间（所有进程共享这块空间）

VOLATILE：禁止进程的编译优化 关键段，临界区 只适用于同一进程(用户模式下的线程同步)

1.