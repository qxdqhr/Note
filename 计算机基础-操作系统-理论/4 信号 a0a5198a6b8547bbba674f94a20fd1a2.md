# 4.信号

##Linux学习笔记—-信号机制 ###信号机制概述

### 信号机制的定义：

> 信号是Linux系统中某种消息通知 / 进程间通信机制，且信号机制兼容于多种系统 >Win中也可使用信号机制，但没有Linux系统中灵活
> 

### 信号机制的作用：

> 内核使用信号终止或挂起进程，绝大多数信号都可以终止一个进程用户使用 终端组合按键 发送信号 以终止或挂起进程利用信号的特性开发服务 >信号捕捉：将信号原功能转化为消息触发功能,使用信号向其他进程发送通知利用信号完成进程间通信 >发送信号时让信号携带数据
> 

> PS:在服务器后台开发维护过程中，使用维护脚本在程序外部使用信号控制程序（使服务器暂停/挂起/恢复/终止运行），不能直接操作服务器
> 

### 信号的数量和种类：

> Ubuntu 16.04系统中共有==64种==信号unix经典信号 1-31号: >软件开发使用，由各个系统自带NPTL线程库使用信号 32，33号： > 被系统隐藏，不能被用户使用自定义信号或实时信号 34-64号:
>底层硬件开发使用，后期由开发需求所添加
> 

### 常见操作中关于信号机制的解释：

> Ctrl+c终止进程的实质： > 内核向当前进程发送一个SINGIN信号(2号),使当前进程终止段错误(核心已转储)的实质： >内核检测出程序异常后,向该进程发送一个信号终止此程序并且显示终止原因常见错误原因： >段错误：非法操作内存 >浮点数例外：CPU非法运算（eg：计算时让一个数除0） >总线错误:多线程中调度异常
> 

### kill函数与kill命令：

> 都能向某一进程发送一个信号，此信号能够终止该进程 使用kill -l （list）命令 ，查看系统下所兼容的信号 kill命令是通过kill函数实现的
> 

### 产生信号的几种方式

> 1.命令产生 >kill-信号编号 进程id2.终端组合按键产生（仅有三组按键可产生信号） >  CTRL+C  ：产生SINGIN信号（2号信号）,使进程终止 >  CTRL+  ：产生SIGOUT信号（3号信号）,使进程终止 >  CTRL+Z  ：产生SIGTSTP信号（20号信号）,挂起当前进程3.硬件异常产生：大多为内核终止异常进程 >非法操作内存（段错误） 产生SIGSEVG信号（11号信号） CPU非法运算（浮点数例外）产生SIGFPE信号（8号信号） 多线程调度异常（总线错误）4.系统函数产生信号（三个系统函数） >int kill（pid_t pid，int sig） >>功能：向任意进程发送任意信号 > >>参数： >pid_t pid：进程id >int sig：信号编号 > >int raise（int sig） >>功能：仅能向自身进程发送信号（谁调用给谁发） > >>参数： >>int sig：信号编号 > >Abort（void） >>功能：仅能向自身进程发送一个SIGABRT信号 > >>参数： >无5.软条件产生信号（指人为产生的信号；硬条件：硬件产生） > >alarm()定时器：定时函数产生信号 >作用：仅进行开始定时/定时结束操作 > >>与sleep函数的区别：alarm函数仅进行定时与定时结束操作,而sleep函数
> 

到时接受一个信号（SIGALRM） 内核使用SIGPIPE信号杀死管道写端

信号小举例 定时器定时，查看计算频率和次数 Linux中 参数为定时几秒 返回值为人为结束定时时仍剩下的秒数

结果不能表示计算机CPU运算能力 计算快，但输出慢 ##### 信号的三大行为与五种动作

> 信号是一个通知，同时也有操作（？？） 每个信号有各自的动作 通过信号以选择行为 默认行为 SIGDFL：存在五个默认处理动作 TERM： 直接杀死进程 CORE： 不仅杀死进程还生成转储文件（出现：核心已转储） 当程序出错，系统生成core文件， 配合调试器可以快速找到出错原因 IGN： 忽略信号，什么也不做 STOP： 使进程被挂起 COUNT：使进程被环形执行 忽略行为SIGIGN：无操作 自定义行为（捕捉行为）：执行自定义工作 信号失效的几种方式：目的：改变信号的行为（不改变则直接执行默认行为中的对应信号的行为） 1）忽略信号 2）阻塞/屏蔽信号 3）捕捉一个信号
> 

信号的传递过程

CTRL只杀当前进程的原因 前台进程：永远只有一个（操作那个进程哪个进程是前台进程） 后台进程： CTRL+C:仅杀死前台进程 CTRL+C被交给线路规程（用于识别录入按键是什么） 识别出按键后发送通知给内核， 通知内核像前台进程发送信号（SIGINT） 给前台进程中的PCB（进程的内核空间）

两个信号集（数组）（每个大小32位） 每一位都对应一个信号 默认情况下数组中的每一位都是0 两个信号集 未决信号集（记录信号状态（开始时为未决态，未处理），判断是否可以通过） 阻塞信号集/屏蔽字（用于屏蔽哪个信号） 内核记录信号状态（内核设置更改未决信号集） 用户决定是否屏蔽信号（用户自定义设置更改阻塞信号集） 0代表可通过 （通过屏蔽字后进入handler） （通过未决信号集后进入阻塞信号集）

1代表不能通过（为1时，信号直接丢弃） 信号穿过信号集后对应位从0置为1

信号到Handler（信号的处理流程，开始处理行为）

屏蔽阻塞一个信号：通过未决信号集后对应屏蔽字集为1 可以暂缓信号处理，但当前信号并未消失 经典信号不支持排队 再来相同信号时就丢弃 自定义信号支持排队 自定义信号中存在排队队列 待处理信号放入排队队列中

现在想让某个信号失效：使阻塞信号集对应阻塞

屏蔽信号后降低系统安全性 系统安全由信号保证（无法杀死病毒，无法检测处内存误操作） 存在两个信号直接为内核服务 无法被屏蔽和阻塞和忽略和捕捉 只要发出必定挂起 只要发出必定杀死

Kill -l查看信号编号对应信号 平台不同进程号对应的进程

三种是信号失效的方式： 1。屏蔽信号 2.忽略信号 3.捕捉信号

1.屏蔽信号：自定义一个屏蔽字用于替换原有屏蔽字 进程默认的信号是无法修改且不能屏蔽的 1.准备信号集（屏蔽字）类型：sigset_t 2.初始化信号集函数 3.设置信号集： sigaddset（sigset_t *，int） sigdelset（） 4.替换进程屏蔽字 sigpromask（） 替换方式：SIG_SETMASK 使用哪一个信号集进行替换： 将原有旧的屏蔽字保存/丢弃： 保留 传入变量 丢弃 NULL

下午：TODO

10.26.2019 利用信号技术完成进程间通信

。。。是基于内核的 假设有两个进程，和一个数据包 进程A要将数据包发给进程B A先给B发送一个信号（任意信号） 发送信号的同时可以携带一个数据包 信号有默认处理函数（默认动作） 设置为自定义动作（自定义的捕捉和函数） 捕捉函数是由进程B设置的，由内核调用（内核到用户空间调用） 函数，有一个参数， 携带数据包的信号中数据包由内核取出，调用信号捕捉函数时传递参数 老接口仅有一个参数int，不能放数据包（只放信号编号） sig_job函数不能用sa_handler接口，不支持 使用新接口： 结构体：struct sigaction act act.sa_sigaction=void(*sa_sigaction)(int n,siginfo_t*,char*) [函数指针，参数有三个，信号编号，数据包结构体指针，] act .sa_mask(不变) act .sa_flags=SIGINFO(TODO:???) A传递给B B传递给A B进程设置另一信号以区分，在进程A中设置自定义信号捕捉函数 达成进程间信号通信 发送信号的同时传递数据的函数 sigqueue（pid_t ,int signo,union sigval） [进程ID，信号编号，数据包联合体] 联合体中有的成员（）数据包中的成员 Int sival_int char*  sival_prt 联合体用int不能用char*（仅能用一个）

Siginfo_t的结构体中也有int成员和char*成员 联合体使用哪种数据时，存到数据包结构体的就是哪种类型？？？

实践：实现父子进程利用信号实现交叉报数 大体思路： 父给子发什么信号，子给父发什么信号 捕捉信号， 不能使用系统使用的信号和组合按键的信号（SIG_QUIT等） 会产生错误 占用住CTRL+C信号 可以使用两个信号（仅两个）来自定义，其他信号都有自己的含义

10号 SIGUSR1 12号 SIGUSR2 默认动作杀死信号，先捕捉成功，在发送 所以选定 父进程发送SIGUSR1捕捉SIGUSER2 子进程发送SIGUSR2捕捉SIGUSER1

此两个成员用于接收联合体中数据

实现：

Ipc进程间通信的缩写

流程： 先在主函数中写 1）信号杀死进程问题：先完成父亲信号捕捉流程

Shif+k帮助文档

调用函数捕捉动作 2）父进程创建子进程 a.紫禁城一上来就要捕捉 3）子进程捕捉流程 防止被杀死 信号屏蔽：阻塞信号集 屏蔽字会被继承 父亲中屏蔽子进程中也会屏蔽 所以要在父进程中屏蔽，在子进程中就不会被杀死 如何屏蔽 初始化屏蔽字 设置屏蔽字（哪个信号集（地址），哪个信号） 替换当前进程的屏蔽字

紫禁城被捕捉后要解除SIGUSR1的屏蔽（重新设置）

此时子进程就能够不被信号杀死，但还要执行操作，所以要先睡一会

乒乓球发球只要一次 （父进程来做） 发出后双方只执行，捕捉，回传（逻辑死循环） 父进程中数据的发送 定义存储数据的联合体 Pid为紫禁城id 联合中保存的是值，不是指针 动作函数中的操作 1）打印数据包中的数据 a.直接打印

2）++（重新计算数据）

3）信号回传数据 a.得不到子的pid怎么办 a)子id为父id+1，一父一子 b)一父多子 c)封装结构体，将指向结构体的指针作为参数传递， d) 4）小睡一会 5） 子进程的操作和父亲大致相同传pid不再加一

需头文件

两个操作函数

实现一个mysleep 信号捕捉结合定时器 Alarm（）定时器函数 Pause（）挂起函数：谁调用挂起谁（进程） 进程到时间内核向定时器发送一个SIGALRM信号 SIGALRM信号的默认动作时TREM终止进程 采用信号捕捉使信号失效 Pause看到信号就会唤醒进程 只看信号，不执行（只能看到有处理动作的信号） 默认（有处理动作）。忽略（无处理动作）。捕捉（有处理动作） IGN忽略信号无动作，pause看不见 定时-等n秒-内核发送信号-pause看到信号-唤醒进程 存在一些隐患 定时前触发其他信号 内核在进程运行时，不会发送信号（发送信号是为了要杀死进程） 具体实现 返回未睡够的时间 参数要睡多久 Alarm（参数）会触发alarm信号

捕捉写在mysleep中

捕捉的目的： 信号失效 处理动作（让pause看见） 没有工作 没有工作算动作吗？算 只要有一个从处理函数的端口 工作无必要

信号来了还没捕捉就会使信号被杀死 此代码不会触发此问题 只有alarm会触发alarm信号 每次都要重新设置信号，设置捕捉，（开销大） 但如果要解决开销大的问题就要把捕捉代码写在外面（自己实现）

信号捕捉 捕捉函数的处理过程：

1内核帮助调用捕捉函数 传入参数为传入信号的序号 2信号的处理非实时

内核完成信号的检测和处理

内核向进程发送一个信号，进程从用户空间切换为内核空间 （用户空间不能处理信号，只能在内核空间使用内核空间处理信号） 中断，异常，系统调用，都能使进程从用户空间转换为内核空间的权限切换 内核空间拥有最高权限 信号捕捉是用户自定义的模块函数 信号捕捉使一个进程有两个工作区，用户main工作区，内核signal工作区（可能引发冲突）

先递送各种信号，但用户空间不能处理信号只能在内核空间中处理 当发生中断异常系统调用后，进程切换到内核空间 切换到内核空间后 1.先处理中断，检测异常，完成系统调用 2.检测系统中是否有未递送的信号，即处理信号 3.由于信号捕捉模块在用户空间，进程携带内核权限，切换到用户空间帮助调用信号捕捉模块，此时虽然是内核帮助调用，但仍使用的是进成员有资源，不会消耗其他系统资源之后内核空间执行SIGNAL信号捕捉模块函数，进程执行模块函数执行完毕后会跳回内核空间 4。任务结束后向用户发送通知（发送给主模块，使其能够从中断的地方继续正常运行）

信号捕捉使一个进程的两个工作区（用户main工作区，内核signal工作区）引发的冲突

连续发送三个信号原因 为避免捕捉动作的冲突，当信号处理时，内核临时设置屏蔽，拒绝相同信号递达 经典信号只支持1次排队