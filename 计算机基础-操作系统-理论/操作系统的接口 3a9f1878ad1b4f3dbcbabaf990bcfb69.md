# 操作系统的接口

# 应用程序如何穿过操作系统操作硬件

- 用户操作应用程序,应用程序通过接口操作系统,操作系统通过接口操作计算机硬件

# 接口

- 电源插座,汽车油门
- 连接两个东西,信号转换,屏蔽技术细节
- 上层应用与操作系统之间就存在接口

## 用户如何使用上层应用

- 命令行 运行程序
- 图形化界面 操作程序
    - 系统消息队列(操作系统中)
    - 应用消息队列(操作系统中)
    - 应用程序内部的消息循环

## 接口如何被上层应用调用:系统调用

- 应用程序中,使用 **高级语言编程** 以及 **对应操作系统的 API 函数** ,即可使用程序调用系统接口
- 由于这类函数都是有操作系统提供
    - **操作系统的接口函数** 也被称为: **系统调用(system_call)**
- 系统调用 对于不同操作系统 具有一套标准 :
    - POSIX(Portable Operating System Interface of Unix
    - (IEEE制定的一个标准族)
    - 学习系统调用的手册

## 接口向下如何在操作系统中运行:系统调用的实现

### 已知:

1. 系统调用 和 用户自定义的函数 的代码都在内存中
2. 系统调用 是 **操作系统带有的函数** , **应在操作系统的代码分区实现**
    1. **操作系统所在的代码分区** 即是 **0 地址开始的内存空间**
    2. **操作系统所在的代码分区** 也被称为 **内核**
3. 用户自定义的函数 的代码 
    1. 至少不应该和操作系统代码 放在一起

### 问题:  为什么要区分内核和用户?  用户直接访问操作系统内核的内存是否可行?

- 不可行
1. 直接从用户的函数跳转到另外一个用户的函数 被称为函数调用 而非系统调用
2. 操作系统中包含许多重要的数据
    1. root 用户的密码:安全性
    2. 可以通过缓冲区任意读取数据:安全性

### 如何实现区分用户和内核:硬件设计

- 操作系统将整个内存划分成 2 段:
    - 用户段:用户态的代码所在的内存段
    - 内核段:内核态的代码执行在用户段
    - 计算机通过 **段寄存器存储内存段** 来使用内存
    - 

### 段寄存器(共 4 种):

- CS: 代码段寄存器 Code Segment
    - CPL:
- DS: 数据段寄存器 Data Segment
    - RPL
- SS: 堆栈段寄存器 Stack Segment
- ES:  附加段寄存器 Extra Segment
- DPL: 目标内存段的特权级 的描述符
    - 存在于 GDT 表中,刚启动后初始化为 0 (head.s )
    - 0 表示特权级较高:内核态特权级
    - 3 表示特权级较低:用户态特权级

[用户态和内核态:进程的运行权限](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%8E%A5%E5%8F%A3%203a9f1878ad1b4f3dbcbabaf990bcfb69/%E7%94%A8%E6%88%B7%E6%80%81%E5%92%8C%E5%86%85%E6%A0%B8%E6%80%81%20%E8%BF%9B%E7%A8%8B%E7%9A%84%E8%BF%90%E8%A1%8C%E6%9D%83%E9%99%90%208333c5b78a454bc5b57ce79b64cf11bf.md)