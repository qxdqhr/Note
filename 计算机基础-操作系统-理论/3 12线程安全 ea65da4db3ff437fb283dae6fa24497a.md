# 3.12线程安全

## 线程安全的两部份工作

### 第一部分

- 数据资源保护：通过对全局变量加锁(互斥锁，自旋锁，进程锁)，避免多线程访问全局资源所产生的冲突，从而保证数据安全。 ### 第二部分
- 线程控制，即调度各个线程的工作，使多条线程能够按照开发者的意愿进行工作。 ### 线程调度的概念：
- 根据需求和实际工作对线程进行控制和调度，同时避免不必要的开销。

### 线程调度的两种方法：

- 信号量
- 条件变量

### 为什么要调度线程的工作？

- 多线程工作时采用 ==并发== 工作形式，即,多条线程会竞争资源，
- 会导致某一线程可能会多次连续获取资源，之后才切换到其他线程，
- 而在某些开发环境下，开发者希望两个线程对一个资源进行交替的访问，
- 需要对两个线程进行控制，
- 使得某时刻不允许其中一条线程参与工作，进而使得工作有序交替。
- 调度线程同样可以使用条件判断的方法完成，但实现原理与调度线程工作的方式是不同的；
- 并且条件判断的方法会产生较大系统多于开销，
- 条件判断的方法：假设当某一线程在其不该工作的时候，争取到了系统资源（被分配到了时间片），却只能空耗资源，不做工作，只进行了大量无用条件判断。
- 而使用条件变量能够在某一线程不应工作时，只处于挂起状态，也不会获得时间片，

### 条件变量：

### 条件变量的实质：

- 通过==某一逻辑条件==,让多线程==交替挂起和唤醒==
    - 符合条件,使线程执行工作
    - 不符合条件,使线程停止工作 #### 条件变量的使用：
- 条件变量 :
    - pthread_cond_t cd

### 条件变量的相关函数：

- pthread_cond_init(&cd,NULL)
    - 参数：
        - cd 条件变量地址
        - NULL 条件变量属性
    - 作用：初始化一个条件变量
- pthread_cond_destroy(&cd)
    - 参数：
        - cd 条件变量地址
        - 作用：销毁一个条件变量
- pthread_cond_wait(&cd,&lock)
    - 参数：
        - cd 条件变量地址
        - lock 互斥锁
    - 作用：
        - 解开锁，挂起线程
        - 接收到信号后唤醒线程，并对全局资源变量上锁
- pthread_cond_signal(&cd)
    - 参数：
        - cd 条件变量地址
    - 作用：唤醒一个挂起在当前条件变量中的线程
- pthread_cond_boardcast(&cd)
    - 参数：
        - cd 条件变量地址
    - 作用：唤醒所有挂起在当前条件变量中的线程

### 条件变量和互斥锁的关系：

1. 条件变量时由互斥锁所衍生而来。
2. 条件变量只能与互斥锁进行配合使用
3. 绝大多数情况下，使用条件变量时，都会使用互斥锁。

### 示例：

- 目标： 两个线程交替工作，各自操作counter 5000次，结束时counter值为10000
- 条件变量的条件： 根据基数counter来设定判断条件：奇数和偶数

### 两线程的工作流程：

- 线程A：条件为：若counter为==偶数==，则挂起等待，挂起在条件为==偶数==的条件变量上 对基数counter进行操作， 当counter不符合条件使得自身线程不能工作时，挂起前线程A会唤醒其他线程 唤醒时可以唤醒其他一个线程/唤醒所有线程
- 线程B:条件为：若counter为==奇数==，则挂起等待，挂起在条件为==奇数==的条件变量上 对基数counter进行操作， 当counter不符合条件使得自身线程不能工作时，挂起前线程B会唤醒其他线程 唤醒时可以唤醒其他一个线程/唤醒所有线程
- 注意：
- 条件变量的数量取决于工作条件的数量。
- 每个线程挂起时,选择挂起的条件变量是此线程所不满足条件的条件变量。
- 本示例中，实际情况是每次仅有一条线程对公共资源进行访问，不会真正遇到多线程访问冲突，是一种特殊情况。
- 但由于示例中涉及到多线程可能要对同一公共资源进行访问，仍要对其加上锁。
- 判断是否符合条件也应放在锁中：
- 要对counter加锁，而条件判断也是对counter进行读访问

### 示例的代码实现：

```
//使用条件变量完成线程简单控制，两个线程交替执行
#incude<stdio.h>
#include<stdlib.h>
#include<unistd.h>
#include<pthread.h>

int counter;
pthread_mutex_t lock;   //互斥锁
pthread_cond_t cd       //条件变量，条件变量的数量取决于工作条件的数量
                        //两条件时，也可以使用一个条件变量表示
void * THREADA(void *arg)
{
    while(1){
            //先对公共变量上锁，防止其他线程调用
            pthread_mutex_lock(&lock);
            //偶数时挂起
            while(count % 2 == 0){
                //即使被本线程获取到CPU资源，但此时本线程不应工作
                //先将刚刚上的锁解除，使其能被其他线程获取到
                //之后在挂起
                pthread_cond_wait(&cd,&lock);
            }
            //奇数时工作
            printf("Thread A TID:[0x%x] ++Counter=%d\n",(unsigned int)pthread_self(),++counter);
            //线程工作后，发送一个信号，给条件变量，使其释放另一被挂起的进程
            pthread_cond_signal(&cd);
            //本次工作已经完成，应释放本线程对共有资源的锁，使其能被其他线程获取
            pthread_mutex_unlock(&lock);
    }

}
void * THREADB(void *arg)
{
    while(1){
            //先对公共变量上锁，防止其他线程调用
            pthread_mutex_lock(&lock);
            //奇数时挂起
            while(count % 2 != 0){
                //即使被本线程获取到CPU资源，但此时本线程不应工作
                //先将刚刚上的锁解除，使其能被其他线程获取到
                //之后在挂起
                pthread_cond_wait(&cd,&lock);
            }

            //偶数时工作
            printf("Thread A TID:[0x%x] ++Counter=%d\n",(unsigned int)pthread_self(),++counter);
            //线程工作后，发送一个信号，给条件变量，使其释放另一被挂起的进程
            pthread_cond_signal(&cd);
            //本次工作已经完成，应释放本线程对共有资源的锁，使其能被其他线程获取
            pthread_mutex_unlock(&lock);
    }

}
int main()
{
    //初始化资源
    pthread_mutex_init(&lock,NULL); //初始化一个互斥锁
    pthread_cond_init(&cd,NULL);    //初始化一个条件变量
    pthread_t tid;                  //创建线程A，线程B
    pthread_create(&tid,NULL,THREADA,NULL);
    pthread_create(&tid,NULL,THREADB,NULL);
    while(1);                       //为避免整个进程终止，使主控线程阻塞
    pthread_mutex_destroy(&lock);   //销毁互斥锁
    pthread_cond_destory(&cd);      //销毁条件变量
    return 0;
}
```

### 总结：

涉及到多线程访问共享资源，就要使用锁机制，保护全局公共变量 涉及到多线程控制(控制，挂起，唤醒，交替工作，根据逻辑条件判断线程工作)时，使用条件变量或信号量