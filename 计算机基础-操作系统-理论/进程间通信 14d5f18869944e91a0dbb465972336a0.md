# 进程间通信

# 什么是进程间通信?

- 使用一个进程以修改其他进程中的变量的操作

# 进程间怎么通信的?

## 内核对象:

- 各个进程之间的用户空间是私有的,想要在进程间传输数据,需要在进程的共享区中进行操作
- 用户的内核空间是共享的
    - Windows下2G~4G
- 内核对象一般由句柄来控制
- 内核对象:事件

## 事件:

### 事件分类:

- 人工事件:需要手动改变事件的状态
    - 线程和事件都需要设定
- 自动事件:能够自动改变状态的事件
    - 当事件变为有信号时调用WaitForSingleObject函数超时后,事件被自动的置为无信号
    - 重新运行线程时,也需要重新设定事件
        - 能自动置为无信号,但不能自动置为有信号

### 通信流程:

- 创建事件:(有信号/无信号)
    
    ```
    HANDLE CreateEvent(
      0,//安全属性
      TRUE, //人工事件,false表示自动事件
      0,//0表示无信号
      _T("MyEvent")//事件名,用于跨进程使用
        );
    
    ```
    
- 按钮中将事件置为有信号
    
    ```
    SetEvent(HANDLE)//参数为内核对象句柄
    ```
    
- 线程函数中将判断是否为有事件信号
    
    ```
    WaitForSingleObject(HANDLE,//内核对象句柄
                      int //设定等待时间单位为毫秒
                      );
    //WaitForSingleObject函数的返回值:
    //WAIT_OBJECT_0:等待超时
    ```
    
- 跨进程使用事件时,调用hOpenEvent函数
    
    ```
    HANDLE hOpenEvent(
      EVENT_ALL_ACCESS,//以何种权限打开事件
                      //直接付给所有权限EVENT_ALL_ACCESS
                      //仅修改事件状态权限EVENT_MODIFY_STATE
        0,//继承性,一般为0
        _T("MyEvent")//事件名,跨进程使用
    );
    ```
    
    - 此函数返回值为句柄,可以说是打开了内核空间中的另一已经创建的事件
    - 仅需判断返回值是否存在,即可调用SetEvent对事件进行修改
- 注意:
    1. 使用时间不断地开启关闭线程时,每次使用事件将线程杀死后需重新创建一个线程
        - 线程完成工作函数后即自然退出
        - **在重新创建线程时也应该重置事件**
        - `ResetEvent(事件句柄)`

### 消息

MFC中的消息机制

POST

Send

### 共享内存

全局堆区申请的空间 global_Alloc() eg：ctrl+c 在任意进程都可以粘贴到 ### 套接字（网络间进程） ### 文件映射（读写大文件） 将磁盘上的文件映射到了。。。 只拷贝一次 提高了文件传输效率 ### 管道 ### DLL：动态库进行进程间通信

其中通信效率最高的是：1，3基于内核模式下 1只能用于发通知 3 可以发送数据