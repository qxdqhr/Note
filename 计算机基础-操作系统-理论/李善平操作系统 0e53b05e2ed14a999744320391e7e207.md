# 李善平操作系统

多种操作系统的使用： Windows Mac Linux 不同操作系统的区别

Mac中滑屏操作是如何通过操作系统实现的

文本界面与GUI各自的优点，各自的缺点

程序和操作系统的交流是系统调用

能理解任一操作系统中一部分的源代码分析

进程:所有的程序都有IO操作与CPU指令的交替使用 这样CPU利用率就不能达到100% 若在多程序运行中使得AB程序的IO操作与CPU使用完美交替使用使得CPU利用率达到100% eg:A在IO操作时,B使用CPU;B在IO操作时,A使用CPU;(操作系统目的:资源高效地运行)

进程概念的引入:(为什么不能沿用“程序”的概念) 多个用户使用同一程序时(学生选课),因为此时相同的程序同时被放入内存,但是两程序所服务的对象(即用户)是不同的; 此时相同的程序处理了不同的数据; 如何区分在内存中运行的两个相同的程序,从而引入了进程的概念; a program in execution; 进程的三个维度: 进程在执行什么程序 进程在处理什么数据 进程正处于什么状态 进程的三个维度若有一个不相同,则代表两进程不同;

是一个动态的概念,进程有自己的生命周期;

C语言编译程序的进程的几大部分:程序运行后在内存中的实际分布形式(进程映像) stack:堆栈空间,局部变量在进入一个函数后,函数中的所有局部变量都可使用(在堆栈中有效),当程序运行的函数运行结束跳出, heap:堆空间,malloc所申请的空间, data:公共数据段,全局变量/静态变量 text:代码段,存放代码

进程的几个状态: new:进程的起始状态 terminated:进程的终止状态 ready:就绪,程序已全部进入内存,数据也已经到位,只差CPU资源,分配到CPU资源后可以开始执行 running:执行,进程利用CPU正常运行 waiting:等待,等待某一资源(IO/进程通信时对方进程的通信资源)未收到资源,进程无法执行下去;eg:执行到输入语句,等待输入设备给予输入 不同操作系统中不同进程中状态有差异.

从数据结构的角度来看进程问题: 数据结构:进程控制块PCB 算法:进程调度算法(创建,终止,通信,寻道,打开文件操作)

进程控制块PCB:反映进程概念的对应的一个实体,一个PCB对应一个进程 内包含成员: 进程号(process number):一个正整数,每个进程号绝不可能重复. 进程状态(process state): 多个 CPU 程序寄存器: PC(programming counter):指向代码段的一个指令寄存器 CPU register:通用寄存器 CPU调度信息:(CPU schedule)(用于CPU调度算法)几十-上百字节 内存管理相关信息(memory management):上百字节,指向代码段的指针 记账信息(Account information) : 使用CPU多少资源,使用多少内存,打开多少文件,使用什么设备,使用CPU多少时间,等) 设备运行状态 IO state 内存限制大小(memory limits):进程的内存使用值的上下界 打开文件链表(list of open files):进程已经打开的文件链表

进程就绪队列:进程在转化到就绪态的时候被放入进程就绪队列,所有就绪态的进程都位于此队列中,当要为就绪态的程序分配内存的时候,直接从进程就绪队列中取出首个进程,并为其分配CPU资源,不用考虑其他状态. IO等待队列:

若计算机中每一个进程都有一个PCB,总消耗空间很大;

为节省空间,过去采用的方案是:将PCB分成两块频繁使用的–放入内存中,不频繁使用的–放入硬盘中; 然而这样在引用硬盘中的PCB资源时,极大的影响了效率.

现今采用的方案是:向PCB中尽可能放入少的数据资源,但PCB整体仍位于内存空间中; 此时多个进程之间,若某一数据是共享的,将此部分数据不放入PCB中 仅有某一进程独占的数据,将此段数据放入此进程的PCB中

不同的程序处理同样的数据: