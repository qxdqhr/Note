# 9.进程在内存的分配

进程在。。的内存分配方式 碎片： 内部碎片：一大块内存只用了一小块（太占空间） 外部碎片：残留在系统中无法被使用的 1. 连续分配： 1. 单一连续分配:内存=操作系统+作业1+作业2… 1. 效率低下且浪费空间 2. 固定空间分配：将一整块空闲内存分成同样大小的空间块形成的空间链表中 3. 动态空间分配：根据需要要多少给多少：减少内部碎片的产生,减少空间的浪费 1. 首次适应算法：每次都从头开始分配，不够向后走，此算法会使前方空间过于碎片化 2. 循环首次适应算法：指针记录上次分配空间的地址按照地址去增减,无效率提升 3. 最佳适应算法：按照容量大小递增的方式排序（分配效率最高的算法） 4. 最差适应算法:找出最大的内存空间进行分配 # 连续分配方式的改进—拼凑技术： 将多块内存拼出来一块，返回（很浪费时间）

2.非连续分配方式（离散的）： 操作系统将内存块划分成页来管理; 页式管理:（一页多大）将4G大小内存分配成（512b-4kb）大小一页（过大过小都不好） get system info 函数 逻辑–页 物理–块

假设4098（？）在第一页（从0开始）4096一页 页号=地址除以页的大小4096 页内位移=地址取余页的大小4096 # 页式管理的寻址方式:(逻辑地址找到物理地址) 页表寄存器:存储页表的实址(首地址)以及页表的长度 页表中有页号及页号所对应的块号

通过页表寄存器中的页表首地址找到页表中对应页号的对应块号取得快地址（实际物理地址）进而找到内存的物理地址

内部碎片： 页式管理：方便了操作系统的管理（用户为方便）

C盘的根目录下有一个页面交换文件 在运行的内存会。。。交换。。。中断。。。。

# 段式管理

段大小由用户需求决定 段表寄存器用于找段表的实际地址 查找方式相似，分配方式不同

两种结合—段页式管理 一段里存在n页

段页式管理会产生；；；；底层仍按叶分配：碎片为内部碎片 8.操作系统采用分页式存储管理(PAGING)方法,要求() A.每个进程拥有一张页表,且进程的页表驻留在内存中 B.每个进程拥有一张页表,但只要执行进程的页表驻留在内存中,其他进程的页表不必驻留在内存中 C.所有进程共享一张页表,以节约有限的内存空间,但页表必须驻留在内存中 D.所有进程共享一张页表,只有页表中当前使用的页面必须驻留在内存中,以最大限度的节约有限的内存空间 B 执行的留在内存中，页面置换的方式以制作

在一个请求也是存储管理中,一个程序的页面走向为4,3,2,1,3,5,4,3,2,1,5,并采用LRU算法 设分配给该程序的存储块数M分别为3和4,在该访问中发生缺页次数F和缺页率f是() A. 1.M=3,F=8,f=67% 2.M=4,F=5,f≈42% B. 1.M=3,F=10,f=83% 2.M=4,F=8,f≈67% C. 1.M=3,F=9,f=75% 2.M=4,F=9,f≈75% D. 1.M=3,F=7,f=58% 2.M=4,F=6,f=50% FIFO算法先进先出算法： TODO： LRU最近最久未使用算法： 在序列中则算命中 不在序列中则需要缺页中断（缺页中断数+1） LRU练习 432 321 213 135 354 543 421？？ 321 215

4321 4213 2135 1354 1543 5432 4321 3215
4 5 6 7 8 9

9次缺页中断 （页面置换算法。doc）

clock

采用()不会产生内部碎片(内零头) A分页式存储管理 B分段式存储管理 C固定分区式存储管理 D段页式存储管理 答案:B