# 进线程这玩意

# Linux下的进程

- Linux下的进程具有较强的亲缘关系，通过亲缘结构管理多进程模型

# 一个进程长什么样（进程的虚拟形态）

# 进程中资源的分类:

- CPU资源:时间片
- 内存资源:存储空间
    - 操作系统中所有内存的分配都是按照页来分配,即,内存单位:页
    - 1页=4096Bytes=4k（绝大多数）
- 文件系统块单位：4k

# 操作系统中的一些权限:

## 操作系统对于内存的访问权限：

- 读PROT_READ
- 写PROT _WRITE
- 执行PROT _EXEC
- 无PROT _NONE

## 用户的文件访问权限

- Root权限也只是对文件拥有最高权限，也不能更改

字符常量区无法修改的真正原因：
对该片内存访问权限为只读
Static。。同理，修改后修改权限为只读？

# 操作系统的关键子系统

- 文件系统
- 内存管理系统
- 进程管理系统

# 为什么进程的虚拟地址分配正好为4G？

- 32位系统间接寻页的最大级别为3级
1024*1024*1024=G
64位系统最大级别为4级
1024*1024*1024*1024=T
操作系统中所有内存的分配都按页分配

软件不会随硬件性能的提升出现过于明显的变化

# 用户与内核的不同？

CPU的使用权的不同==演变出的==角色不同
用户与内核都是cpu
对于一个CPU来说
权限级别为3时，没有任何系统核心服务与固件的访问权限，无法访问过多的系统资源，只能使用别人提供的低权限办法。一般用户拥有此等级权限
1级和2级侧重权限不同
权限级别为0时，权限最高，可以直接访问固件驱动层，对操作系统的每个核心服务都有访问控制权限

系统调用：最快CPU权级转换方法
默认最高最低权限互换
当权限不够时仍想调用函数即触发系统调用
什么是系统调用？软件对硬件的某种操作
系统调用完成后权限再切换回来
权限不够的时候找A帮个忙，帮完之后A就会走
使用printf函数时，用户调用printf函数，一串字符显示在屏幕上，但将字符串显示到屏幕上是由系统完成的这个操作即为系统调用

CPU处理能力：1GHZ   纳秒级别的处理能力（1条指令），
绝大多数系统时间片可以满足进程需求

进程就是寄存器和栈
CPU：运算器：
控制器
译码器
寄存器
Inter处理器32位默认16个寄存器
多进程通过分时复用使用Cpu
所有的寄存器一共16个，如果某个进程在使用CPU进行处理和运算，时间耗尽时，会被强制终止，由其他进程来使用cpu，其他进程的运算数据

TODO

进程的调度单位：
进程，线程，纤程，超线程（有比普通线程有更高的权限和使用率），
（协同方案：管程，协程）
二、进程原语（原生的，未二次包裹的系统函数）
二次包裹：对已给现有的函数open函数的错误处理：
目的：增强其健壮性
TODO：

在LINUX下进程间是具有很强的亲缘关系
父进程对子进程负责
而windows弱亲缘的
父进程非必须对子进程负责

父子进程关系如图所示

如果两进程ID是连续的
只能确定两进程存在亲缘关系，而不能确定一定为父子关系，还有可能为爷孙关系（不能代表辈分大小）
同时，若进程ID不连续也不能确定两进程一定无亲缘关系

对于已经存在的父进程及其子进程 父亲ID一定小于子进程ID

多次调用FORK函数
可创建多个子进程

相比于文件系统，文件系统的祖宗为根目录
而进程的祖宗进程ID为1

进程状态：（5种默认常态）

运行态
就绪态
挂起态
仅可以被唤醒不能被人为干涉中断
睡眠态（阻塞态）
可以被强制中断
终止态
Linux独有：僵尸态孤儿态
默认状态：子进程会继承fork后的所有功能并执行

Getpid获取进程ID函数
Getppid获取父亲进程ID函数

Linux下---printf默认不刷新缓冲区--输出需加\n
Windows下--printf默认刷新缓冲区--输出不需

正常流程：
子进程被创建，
子进程去工作，
子进程工作完成，
子进程被终止
要在自己的工作区中结束（exit（0）终止进程）

子进程完成工作后在自身工作区中
应被睡眠/终止/继续工作
不应离开工作区进入父进程
会使父子工作发生混乱
两进程同时对同一内存空间进行读或写操作

# **Fork创建进程（资源继承）详细**

## **父进程创建子进程**

父进程调用fork函数,子进程由内核创建，创建时内核参照父进程创建子进程;
首先,内核进创建一个进程的框架,即,新产生的子进程是不包含PCB与用户空间的,此时的子进程并不能够被称为是一个进程,仅可被认为是一个进程框架;
框架创建完毕后,内核通过父进程初始化子进程;
(子进程与父进程极为相似的原因)
初始化子进程时,父进程PCB中大部分可以继承的变量可以拷贝,但进程ID等独立性强的不会拷贝;即子进程PCB由父进程PCB"克隆"而来（部分拷贝）
同时,对于父进程的用户空间会完全克隆给子进程（完全拷贝）
父进程中定义的变量,子进程能够直接使用(用户栈与父进程相同)但变量是拷贝而非共享(子进程不会修改父进程的变量)

一父十子(进程池,多子进程做同样的事)

父进程每次调用fork创建子进程时,对某一变量进行修改,会导致多个子进程中同名变量的值不同
代码示例:#include<stdio.h>

# **有关FORK函数中的一些问题与改进**

## **子进程拷贝开销:（Ubuntu8.0前的第一版本fork函数）**

当子进程执行父进程所安排的工作时,假设子进程没有使用任何用户资源,内核对父进程向子进程的用户资源的完全拷贝是无意义的,产生无意义拷贝开销

## **解决方案**

### **vfork函数**

- vfork仅完全拷贝父进程PCB,创建的子进程没有用户空间，需要用户自定义,无实际的优化（未真正解决fork函数问题）
- 用户空间为虚拟地址，为空则代表不存在用户空间.所以,Vfork（创建初始化进程）函数必须结合于exec（载入用户空间）函数使用,这样子进程才能完整;
- exec能够将其他进程的用户空间拷贝至另一进程（需要权限）

### **第二版fork函数**

- 使vfork函数被废弃,几乎不被使用
- 创建读时共享，写时复制的机制，避免额外的拷贝

### **读时共享:**

- 父进程中的具体变量存在一块具体内存中,子进程读取变量时,读取的实际是父进程中的变量的内存空间中的值,此时并不会有任何拷贝开销;
- 子进程在读取资源时，与父进程访问的是一个同一个用户空间（共享资源），某一刻子进程要改写共享资源，内核检测到就将用户空间拷贝给子进程一份

### **写时复制:**

- 子进程一旦写入用户空间,父进程为子进程拷贝整个用户空间;

### **读时共享写时复制的解释:**

- 你能够看到我有的东西
- 你如果用，我就全给你
- 你如果不用，什么都不给
- 不会你要什么给你什么，因为我再给你找太麻烦

父进程从头运行至尾;

# **fork函数分析**

## **fork函数功能:**

- _CREATE 进程创建
- _CLONE 克隆,读时共享写时复制
    - 初始化PCB
- return 0

两个进程均可调用此函数（共同调用）一个函数调用一部分

### **调用一次返回两次:**

- 两进程能调用同一函数的两个部分
- 第一次返回_CLONE函数返回值:子进程的pid
- 父进程调用fork函数时,仅执行:
    - _CREATE(创建进程)
    - _CLONE(克隆,返回子进程id)
- 子进程调用fork函数时,仅执行:
    - return 0

？？函数栈帧：
？？多个进程调用同一函数时以区分不同进程

僵尸进程	
    定义：
        某进程终止时，其进程的PCB仍未被回收，此进程为僵尸进程
        （父进程或子进程均有可能）
    危害：
        系统内存泄漏
        系统中存在过多僵尸进程的时候，会影响系统中新进程的创建
        （当前系统中能创建多少进程，由系统中PCB剩余可用量决定）
    处理方法：
        wait函数：
        wait函数是阻塞函数，调用一次回收一个进程
            参数可以传空
            返回值：
                回收成功：返回被回收进程的PID
                回收失败：返回-1（无子进程时）
    wait 与 waitpid 完成进程回收：子进程终止，但父进程未将其回收，造成内存泄露，子进程为僵尸进程
    父进程在子进程终止后回收子进程的PCB
    Wait/waitpid 两函数均可回收PCB
    谁家孩子死了 内核不管，由自己父亲收拾（回收）调查死亡原因
    子进程只能通过父进程来完成对子进程的回收工作

```
注意：
    不要让子进程离开自己的工作区域
    （不允许子进程参与父进程工作，子进程结束时使用exit（0）函数结束子进程）
```

扩展：
1）公认命令行系统快于鼠标键盘
VS 是 IDE 集成开发环境  
Build 用于自动构建项目中文件
2） 脚本语言：shell JavaScript Makefile	
服务语言：为高级语言开发编译辅助工具的语言
Python 既可作开发语言也可作服务语言
3）更快的保存并退出：命令模式下：shift+z+z
4）项目编写流程：（如图所示）
①将所有.c文件编译为.o文件（生成核心二进制文件）
②将所有核心二进制文件进行链接
③最终生成app（可执行应用程序）

[编译一个程序的流程](%E8%BF%9B%E7%BA%BF%E7%A8%8B%E8%BF%99%E7%8E%A9%E6%84%8F%20373d566e1c7e4f07a80fbe00dc221d21/%E7%BC%96%E8%AF%91%E4%B8%80%E4%B8%AA%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%B5%81%E7%A8%8B%20756b726c538040b3bbb97b27e66542d9.md)

[进程:doing/todo 的任务](%E8%BF%9B%E7%BA%BF%E7%A8%8B%E8%BF%99%E7%8E%A9%E6%84%8F%20373d566e1c7e4f07a80fbe00dc221d21/%E8%BF%9B%E7%A8%8B%20doing%20todo%20%E7%9A%84%E4%BB%BB%E5%8A%A1%20cdae88c1f42040b8b301c6bddf90e744.md)