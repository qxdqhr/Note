# 2.进程间通信-管道

# 进程间通信机制 的概念：

在开发过程中多个进程需要共享数据或交互数据，必须采用进程通信技术（简称 IPC机制）实现, 进程间通信技术大多基于进程的内核空间来进行

# 进程中的空间分配：

0-3G 用户层（大小3G） ： 每个进程的用户空间是独立的，其他进程不能访问， 只能被进程自身以及进程的（？子进程？）访问，不能实现 3G-4G 内核层（大小1G） ： 内核空间是多条进程的共享一块内存（一块空间中包含多个进程的PCB） 可被多条进程访问，可以实现

# 进程间通信机制的种类：

## 具备网络功能的:

Socket

## 无网络功能，仅能本地进程间通信：

消息队列 剪切板 内存映射 消息队列：POSIX SYSTEMV 管道 信号变量 信号 条件变量 锁机制：例：互斥锁（挂起唤醒） 消息队列POSIX SYSTEMV 信号量

# 进程间通信方式之管道:

## 匿名管道（典型基于内核的进程间通信方式）

### 匿名管道的概念：

- 在两个进程的内核层之间架设一个管道缓冲区
    - 内核缓冲区，大小4096字节=4K
- 使两个进程在内核层能够实现交互
    - 一方向其中写入，另一方从中读出

### 匿名管道的特征：

- 数据流通性：
    - 能够在两个进程的内核层之间流通数据
- 方向性：
- 只能从一个地方流向另一个地方,流入和流出必须匹配
- 管道内的数据是即存即取的

### 管道的结构：

- 环形队列，大小4096字节

### 在内核空间架设管道的原因

（主要）所有进程的内核空间是共享的，能被多个进程访问，而每个进程的用户空间并不共享 系统内任意进程创建了一个管道，其他进程均能检测到管道的存在，即可完成多进程通信

### 创建管道的函数：

```
 int pipe（int fds[2]）
```

### 参数：

读写访问描述符数组的首地址

### 返回值：

### 注意：

​ 创建管道时，仅需要在两进程间建立一条管道（）即可

所创建的管道的流通方向由描述符数组中的两个元素值决定 fds[0]指向管道读取端 fds[1]指向管道写端 进程可通过以上两个元素值对管道读写访问操作 （仅能一端读，一端写）

### pipe函数的运行流程：

函数调用成功，则会在所有进程的内核空间建立一个管道 并向之前定义好的fds数组中传出管道的读写描述符

### 问题:两个进程中各自的用户空间中为什么能使用同一fds数组？

### 疑问原因：多条进程之间用户空间不共享

使用进程A创建管道，创建进程A的子进程B（子进程继承父进程中的所有元素） A进程先调用pipe，使用了pipe的fds[0]空间？？

管道交互数据的方式：读写操作 管道是如何使用户在内核空间 已知： 管道被创建在内核空间 用户不能访问进程的内核空间 用户的读写操作在用户空间中完成 所以，管道为用户提供读和写的访问接口

### 四种特殊情况：

### 只写不读:

- 写端向管道写入数据，读端未读取管道中数据，写端写满管道后写操作会被阻塞

### 只读不写:

- 读端向管道读取数据，写端未写入管道中数据，读端将管道中数据全部读出后读操作会被阻塞
- 使用管道是需要确认通信方向，确认谁读谁写 确定通信方向后，应关闭不需使用的功能 （父写子读应保证父进程无读功能，子进程无写入功能）

### 管道的关闭：

- 管道使用完成后，要关闭管道
- 关闭父子进程中全部指向管道的描述符关闭，才会真正释放管道缓冲区
- 关闭使用管道时，关闭管道锁链接的两进程的FILE结构体

### 管道创建流程：

1. A进程调用pipe函数
    1. 在进程A的用户空间
2. 管道创建成功
    1. 会将管道的读写访问描述符传至fds数组
    2. 描述符数组中,fds[0]指向管道读端，fds[1]指向管道写端

## 有名管道

创建有名管道的方式： mkfifo 内存共享映射：（mmap） 与管道的区别： 在一个进程中将一个文件映射至进程中的映射内存 映射的两种方式：共享映射（MAP_SHARED） 私有映射（MAP_PRIVATE） 私有映射：映射文件将文件中的内容拷贝一份给内存，相互之间再无任何关联（单项拷贝） 共享映射：使用Sync同步机制，将文件中的内容拷贝给映射内存，映射内存和映射文件中数据永远保持一致（双向共享） 是如何实现进程间通信的？ 若有多个进程同时对一个文件进行共享映射， void *mmap（） 参数： 映射内存的位置，系统提供一块内存为NULL 映射内存的大小，绝不为0，一般定为映射文件大小 映射内存的权限： 读（PORT_READ） 写（PORT_WRITE） 执行（PORT_EXEC） 无（PORT_NONE） 映射方式：私有映射/共享映射，要实现进程间通信要使用共享映射 映射文件描述符 偏移量 返回值：一个泛型指针，指向所申请的映射内存的首地址 申请映射内存并实现映射 munmap（） 参数： 映射内存地址 内存大小 返回值

10.13

如果用户穿的参数小于4 报错并执行终止exit（0） 还需要校验限制用户传参，源文件是否存在，是否非0，进程数是否合法

软件开发（）

进程数设置为可选 如果未传进程数 设定默认传入进程 如果传入进程数

Wait函数 回收成共，返回一个pid 如果失败，返回-1 何时会失败：没有子进程时

通过wait函数建立循环（删除子进程并且打印删除拿一个子进）

小文件拷贝多进程无优势，仅在大文件中有优势

进程间通信定义：使用某技术实现多进程交互（数据交互，通知时间交互）都是进程间通信技术范畴

多进程中不一定会使用进程间通信

进程如何通信：通信保存数据的位置是哪 内核空间是共享的 进程间通信技术都是基于内核，也可称之为内核资源共享 用户空间是无法通信是各自独立的

内存映射

管道
实际可读写的一段缓冲区 只有在Ubuntu 16.04系统中管道大小为4096Byte=4K 其他系统版本中 使用的数据结构：环形队列（优点：避免溢出（寻址复用），灵活） 管道所具有的特性： 数据流通性 方向性 在使用管道时间一定要确定（谁写谁读）

匿名管道 匿名管道在进程的内核空间创建一个缓冲区 这个缓冲区中的数据可以被其他进程访问读写 从而实现多进程交互数据

创建管道的函数： Int pipe(int fds[2])

管道的几种使用情况： 管道写满数据后，写入端继续写入则会阻塞 管道为空，读取端再读管道会阻塞 写段终止，读端读管道返回0（相当于读到末尾） 读端终止，写段写管道，内核向写段发送SGIGPIPE信号，终止写端 匿名管道的优缺点 优点：实现较为简单，开发成本低 缺点：只能适用于父子进程通信，如果两个进程没有任何亲缘关系则匿名管道不适用 匿名管道为单工通信，通信方向变更，不够灵活 匿名管理传送的数据是无格式字节流，不利于数据交互 无格式字节流长度不确定，接收端无法确定获取多少数据 有名管道 创建有名管道的两种方式 命令：mkfifo myfifo 函数：mkfifo(“myfifo”,0664) 有名管道通过访问文件方式

读端功能

保护管道： 访问有名管道文件时，必须满足读写权限，才可以访问，否则open函数阻塞，阻塞到权限满足为止 需要两个条件都满足的同时才能。。。

条件变量

锁机制 TODO:补全

使用管道时

要注意写入的数据量 写入的数据量不同，管道的xx方式可能不同 原子访问：写入的数据小于管道大小 非原子访问：写入的数据大于管道大小

有一个4k内核缓冲区 图 假设不断写入的数据1k 当管道神与空间为0时会阻塞 原子访问：更安全（每次发包字节大小相同，从而保证读写数据完整） 写段写入的数据量（一次） 要小于剩余空间（大于时会挂起写进程） 非原子访问：更快 写入的数据量大于总大小 会有多少空间存多少数据 空出一字节存入一字节 读取数据时 ？需要检验（）？ 挂起恢复频率较低，减少开销，速度快

内存共享映射

两种映射方式： 私有映射：MAP_PRIVATE 映射文件仅由内存中文件拷贝得出，无其他关系，仅保证两个地方都有文件 共享映射：MAP_SHARED 共享映射通过使用SYNC同步技术 永远内存与文件的内容是一致的（实时同步）

怎么通过映射进行进程间通信：SYNC同步技术（实现数据共享） 将两个进程均共享映射到一个文件 当一个进程修改了mmap映射内存 会通过映射文件映射至另一进程

通过 映射文件：不能为空文件

Windows中如何使用mmap 必须有一个中转文件的基点（可以是映射文件，也可能是一块映射内存）

Linux中如何使用mmap

映射时文件大小为0时会导致映射失败 mmap内存映射（一块内存）：将映射文件中的内容映射到一块内存（程序空间中）中，使内存中文件与映射文件内容保持一致

私有映射 大数据的文件切片的一种方法–映射将数据文件拷贝出来（每次映射出源文件的数据）（获取数据）（不能动公司中的大数据文件）

使用两个函数 #include<sys.mman.h> mmap（NULL，在哪里申请内存空间（可有内核自动申请空间，也可手动申请在堆区），映射文件的大小（为0使必定失败），内存权限（读写执行无四种权限）PORT_READ位或PROT_WRITE，哪种映射（共享或私有）此粗选用共享，映射文件的文件描述符：fd，映射偏移量（0）） mmap支持整个文件映射也支持部分文件映射（通过映射偏移） mmap返回一个泛型指针 munmap（mmap的返回指针，映射大小（一般为映射大小）释放映空间）

要测试同步技术 修改映射内存 查看映射文件是否也已经修改 lseek可获取文件大小

字符有许多表现形式 十六进制赋值为倒序赋值

设定p为int型指针 通过指针间接引用时。。。 测试结果

读端

扩展空文件 扩展空文件不一定 扩展为数据结构大小 将结构体映射入文件中 先创建一个结构体

从长变短和从短变长截断 空文件阶段到4K会将空文件变成大小为4k的文件（以0填充） 重新为结构体赋值后原来的值就会消失（被覆盖） 若想存多个结构体需要n*结构体大小，访问通过偏移得到 sprintf函数可以向数组中写入固定格式的某些数据

数组的首地址 字符数组遍历赋值 首地址代表整个地址长度，也是首元素地址 字符串直接赋值

将male四个元素放入数组中 直接赋值 是将 字符常量区的地址（4字节）付给数组中首元素（字符1字节），无法存下 并且将地址付+

给元素，字符元素中就是存储了一段地址，直接乱套