# 3.线程同步_原子访问

# 原子访问：

## 实现原理:

- 同一时刻应只允许一个线程访问资源(变量);
- 通过**Volatile**关键字以及**多种原子锁函数**实现; ## Volatile 的作用:
- 禁止编译器的编译优化,实现对特殊地址的稳定访问;
- 使编译器对于 **加上此关键字的变量** 仅能且必须能在内存中被修改,不会被放置在寄存器中; ### 允许编译优化的情况(未加volatile关键字)
- 在进行多变量间的赋值语句时,将赋值变量中的值,放入一个高速缓存(寄存器)中;
- 假设赋值变量值不变,此时,寄存器中的变量值就会被多次重复利用;
- 减少赋值语句的执行次数,提高程序运行效率;
- eg: int i=10; //1) int j=i; //2) int k=i; //3)
- 此时,2),3)句的赋值语句基本相同,所以此时i变量中的值会被放入内存中的一个寄存器中,减少程序反复读取外存中的数据,提高运行效率;
- 这一过程在程序编译期的编译优化过程中完成; #### 出现的的问题:
- 编译优化过程更适用于单线程工作的项目,当出现多线程工作时,就不应允许编译优化的情况出现;原因:
    - 多线程在工作时,一条线程在读取一个变量的值时,由于编译优化的存在,将此变量的值会被移至高速缓存寄存器中;
    - 此时如果另外一条线程修改了这个变量,原线程所读取的值就会使之前线程放入内存中的变量的值(未进行修改的变量值);
    - 这样变量值的修改会乱掉,直接导致多线程工作后的结果错误; ### 解决方法:
- 消除参与多线程修改的变量的编译优化功能(加上关键字Volatile);
- 修改此变量时调用原子锁函数; ## 常用的原子锁(interlocked)函数:
- InterlockedDecrement(某一long类型变量的地址)
    - 使此变量被原子锁锁住,同时,每当一条线程调用此函数时,使锁住的变量值-1;
- InterlockedIncrement(某一long类型变量的地址)
    - 使此变量被原子锁锁住,同时,每当一条线程调用此函数时,使锁住的变量值+1;

## 应用于卖票问题中:

1. 问题出现在有多条线程不同步的对票数变量进行修改,出现了卖同一张票的错误; 可以对票数变量Tickets添加Volatile关键字进行修饰,为此变量添加原子锁
2. 同时,在修改此变量的值的语句(Tickets–;)应修改为调用InterDecrement()函数来实现; ## 出现问题: 原子访问只能锁定一个变量,关键段范围更大