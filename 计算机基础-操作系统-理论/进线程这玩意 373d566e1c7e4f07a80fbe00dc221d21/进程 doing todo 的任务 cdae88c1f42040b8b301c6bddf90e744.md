# 进程:doing/todo 的任务

- 进程是程序的动态执行（占用内存空间）
    - **跑起来的程序**
- 程序是进程的静态存储（占用磁盘空间）
    - **存起来的进程**
- **进程是什么:**进程是一个系统资源调度单位
- **为什么要使用进程:**能够使用系统资源完成特定任务

- 每一个进程都具备PCB，（进程控制块）PCB用于唯一标识进程的信息

# 进程的内部结构(进程的地址空间分配机制)

## 程序应该如何运行:(工厂应该如何开工)

### 初级老板的管理方式

- 管理员(操作系统)收到用户给予的任务(程序)后,并收到用户的开工指令(运行程序)
- 管理员应先在工厂中指定一些工位/机器(分配内存),用于执行工作(运行程序生成进程)
    - 总工位=A生产线占用工位+B生产线占用工位
- 但是,现在出现了一些问题,有时会令管理者很烦恼:
    1. 自己的工厂很小,放置的生产线很少,不能同时开工很多个任务,工作效率低
        1. 物理内存较小,几乎不能并行任务
    2. 生产线都集中在一个地方,两种工作,却要在一个地方办公,很容易发生工作上的冲突
        1. 物理内存有限且连续,执行多个进程的时候,极易发生非法操作内存的问题
    3. 到了旺季,工厂会接收到用户的加急订单,处理加急订单很浪费资源
        1. 先停掉当前正在进行工作A的生产线,并记录A的进度,将半成品放入仓库
        2. 在原生产线上开始加急订单的工作
        3. 加急订单执行完成后将A重新布置在原生产线上
        4. 这样就需要很多人力物力去切换生产线的生产计划
- 这就是早期计算机中进程中内存的分配方式,程序中访问的内存地址都是实际的物理内存地址。
- 这些问题对应了早期进程内存分配的如下三个问题:
    - 问题 1 ：进程地址空间不隔离。由于程序都是直接访问物理内存，所以恶意程序可以随意修改别的进程的内存数据，以达到破坏的目的。有些非恶意的，但是有 bug 的程序也可能不小心修改了其它程序的内存数据，就会导致其它程序的运行出现异常。这种情况对用户来说是无法容忍的，因为用户希望使用计算机的时候，其中一个任务失败了，至少不能影响其它的任务。
    - 问题 2 ：内存使用效率低。在 A 和 B 都运行的情况下，如果用户又运行了程序 C，而程序 C 需要 20M 大小的内存才能运行，而此时系统只剩下 8M 的空间可供使用，所以此时系统必须在已运行的程序中选择一个将该程序的数据暂时拷贝到硬盘上，释放出部分空间来供程序 C 使用，然后再将程序 C 的数据全部装入内存中运行。可以想象得到，在这个过程中，有大量的数据在装入装出，导致效率十分低下。
    - 问题 3 ：程序运行的地址不确定。当内存中的剩余空间可以满足程序 C 的要求后，操作系统会在剩余空间中随机分配一段连续的 20M 大小的空间给程序 C 使用，因为是随机分配的，所以程序运行的地址是不确定的。

### 中级管理者的管理方式

- 在多任务操作系统中，每个进程都运行在属于自己的内存沙盘中。这个沙盘就是虚拟地址空间
- 与虚拟地址空间相对的，还有一个物理地址空间，这个地址空间对应的是真实的物理内存。如果你的计算机上安装了 512M 大小的内存，那么这个物理地址空间表示的范围是 0x00000000~0x1FFFFFFF
- 当创建一个进程时，操作系统会为该进程分配一个 4GB 大小的虚拟进程地址空间。
    - 4GB:32 位的操作系统中，一个指针长度是 4 字节，而 4 字节指针的寻址能力是从 0x00000000~0xFFFFFFFF，最大值 0xFFFFFFFF 表示的即为 4GB 大小的容量

## 32位操作系统中一个进程占有4G的虚拟内存地址块

![%E8%BF%9B%E7%A8%8B%20doing%20todo%20%E7%9A%84%E4%BB%BB%E5%8A%A1%20cdae88c1f42040b8b301c6bddf90e744/Untitled.png](%E8%BF%9B%E7%A8%8B%20doing%20todo%20%E7%9A%84%E4%BB%BB%E5%8A%A1%20cdae88c1f42040b8b301c6bddf90e744/Untitled.png)

### Linux系统中:0G-3G为用户空间;3G-4G为内核空间

- **0-3G,3G-4G均表示虚拟地址**,实际取值是通过这些地址间接得到的
1. 环境变量(操作系统的配置文件):
    1. 进程的配置文件由系统的拷贝而来
2. 命令行参数：
    1. 程序传参（eg:主函数参数）
3. 用户栈：
    1. 用于保存资源数据一些变量及数据
    2. **局部变量,函数参数,返回地址**
    3. 向低地址方向扩张
4. 库空间：保存动态库或静态库中文件
    1. 静态库：不易更新但运行快eg：feiq
    2. 动态库（Linux中成为共享库）：便于更新迭代，程序体积
5. 堆空间：
    1. **malloc出的空间**
6. BSS：
    1. 未初始化/初值为0的全局资源
    2. 静态局部变量
7. DATA：
    1. 未初始化/初值为0的全局资源
    2. 静态局部变量
8. TEXT：
    1. 代码段（保存汇编码）
    2. 字符串字面值
    3. 只读变量

## **进程的两种运行方式：**

- 并行:多个线程在多个CPU上同时运行的运行方式
    - 并行是并发的一种特殊情况
- 并发：多个线程采用轮换线程的时间片的方式
在单CPU上交替的执行的运行方式