# 进程线程基础

### 编译一个程序（程序生成）的几个阶段

1. **预处理阶段**中可能包含的内容:
- 解析条件预处理命令 - ifdef #ifndef
- 定义宏简单的文本替换，无任何安全校验 - define - C语言中问题:内联函数和宏的区别?什么是内联函数？
- 将头文件导入此位置并加以解析 - include
- 注释（在预处理阶段会删除所有的注释） - // ，/* */
- 对文件序号标识
- 当点击错误时会跳转到错误地点，方便调试与管理
- 杂注指令
    - pragma once:只编译一次 - pragma pack(n):告知编译器此程序中按n字节对齐内存 - 由自己定义，在预处理阶段是保留的，不做处理的
1. 编译阶段（对预处理文件进行解析分析）
    - 语法分析
    - 语义分析
    - 词法分析
    - 编译优化
    - 代码生成为汇编代码
        - 注意:代码出现错误时的报错检查一般都出现在编译期
2. 汇编阶段
    - 将汇编代码语言文件转化为机器码语言文件（二进制）
3. 链接阶段
    - 将许多个机器码二进制的文件合成.exe文件,在运行程序时将其放入内存中（生成一个进程） # 进程概述: ## 进程的两种运行方式：
- 并行:多个线程在多个CPU上同时运行的运行方式
    - 并发：多个线程采用轮换线程的时间片的方式 在单CPU上交替的执行的运行方式
        - 并行是并发的一种特殊情况

## 进程在操作系统中的形态:

1. 在32位系统下,一个进程包含4GB的虚拟地址空间
    1. 2字节约等于4GB大小关系
        
        32
        
2. 在64位系统下,一个进程包含16TB的虚拟地址空间
    1. 2字节能表示空间较大,仅选用16TB已经足够
        
        64
        

## 进程的内部形态:(32位)

1. 空指针模式:0~64kb
    1. 此部分空间一般用于调试程序
    2. 大多为0x0000地址,不可直接访问
2. 用户模式:64kb~2GB
    1. 是进程的私有地址空间
    2. 存放new.malloc产生的空间
3. 内核模式(系统模式)2GB~4GB
    1. 是系统中所有进程共享的空间
        1. 由于是共享空间,定义内核对象进行进程间通信
    2. 所有运行中的进程占有空间不能超过2GB
    3. 使用的Widows资源,加载的位图

## 进程的内部形态:(64位)

1. 用户模式:0~8G
2. 内核模式:0~16G

## 创建一个进程:

- 程序运行时在电脑中表现为进程
- 操作系统在创建进程时会为进程分配一个空间
- 进程中真正工作的是线程
- 每个进程中都至少有一根主线程在工作

### CreateProcess函数

帮助文档下:

```
BOOL CreateProcess
(
    LPCTSTR lpApplicationName,  //要打开哪一个进程,进程的路径
    LPTSTR lpCommandLine,       //打开进程使用的命令行
    LPSECURITY_ATTRIBUTES lpProcessAttributes。//进程的安全属性
    LPSECURITY_ATTRIBUTES lpThreadAttributes, //主线程的安全属性     BOOL bInheritHandles,       //进程所继承的句柄
    DWORD dwCreationFlags,      //创建标志:用于设置进程的优先级
    //实时运行:优先级高;屏幕保护:优先级低
    LPVOID lpEnvironment,       //进程的环境块,存储进程的基本信息
    LPCTSTR lpCurrentDirectory, //进程所在路径
    LPSTARTUPINFO lpStartupInfo,//指向STARTUOINFO结构体的指针
    LPPROCESS_INFORMATION lpProcessInformation
    //返回一个进程基本信息的句柄(最重要)
);
```

实际使用:

```
//创建一个字符串,用于存储进程所在路径
TCHAR szbuf[]=_T("");
//定义一个STARTUPINFO类型结构体,用于存储进程的信息
//使用时可仅为大小这一属性赋值
STARTUPINFO si={sizeof(STARTUPINFO)};
//定义一个PROCESS_INFORMATION结构体,用于回传进程的关键信息
PROCESS_INFOMATION pi;
//调用CreateProcess函数
CreateProcess
(
    0,//进程名字
    szbuf,//命令+空格+进程路径的字符串
    0,//进程的安全属性
    0,//主线程的安全属性
    0,//继承性
    NORMAL_PRIORITY_CLASS//创建进程优先级
    0,//环境块
    0,//当前路径
    &si,//进程信息结构体
    &pi
);
```

### 创建进程的应用:

- 做其他程序的启动器,游戏大厅的主界面,直接调用程序创建另一程序的进程

# 线程概述:

- 进程中的执行单元
- 轮换时间片的基本单位
- 分配CPU资源的基本单位

## 多线程的引入:

- 进度条在持续移动,此时发现窗口不能移动
- 形象比喻:
    - 建立工厂时,工厂中被自动配备好一名工人,当产生的工作已经不能完全交给一个人同时完成时,需要为工厂招募其他工人
    - 创建进程时,进程中有一个自动创建的主线程,当产生的工作不能完全由此进程同时处理时,需要创建一些新进程以分担工作
- 产生原因:
    - 一个进程中一般仅有一个主线程
    - 主线程如果进行循环工作,会导致其他工作没有人做

## 多进程“同时”运行的原理:

### 线程并发执行

- 多进程间采用**轮换线程的时间片方式**进行工作
- 时间片即是进程中的线程的工作单位时间
- CPU根据调度算法计算出**默认时间片的时间**(此处假设为20ms)
- 每一个线程每隔20ms运行一次,使得用户使用时没有延迟感

### 线程并行执行

- 现代计算机一般都包含多核CPU:
- 当不同的CPU同时轮换时间片时,多个线程可能在同时运行
- 这种运行方式被称为并行方式,是实际意义上的同时执行

## 创建线程:

```
CreateThread（
    NULL    安全属性，
    0       可以设定线程栈大小值,0表示默认创建1MB大小空间，
    A       需要一个线程函数地址，工人的工作
    this    传递给线程函数的参数，线程函数一般使用本类中成员,传入this
    0       线程状态,0表示线程创建之后是否立刻运行,
                 CREATE_SUSPENDED表示创建之后立刻挂起,
    A       线程ID,返回型参数
）；
```

- 线程函数参数项中,将参数转化类型传入不会影响参数中的具体值

### 线程函数分析:

- DWORD 为usigned long 4字节
- 线程函数原型为全局函数
- 线程函数的调试:
    - 需要在线程函数内部下断点,主线程不一定能走到线程工作函数

### 调用约定：

- 调用函数时,参数是如何放入函数中,存储在哪里
- 每个函数都有调用约定,不写明则使用默认方式
    - 一般使用本语言的函数默认调用方式
- _stdcall:
    - 参数入栈顺序:从右向左
    - 由**函数本身**清理空间
- cdecl
    - 参数入栈顺序:从右向左
    - C语言中调用约定方式
    - 支持可变参数个数
    - 由**调用者**清理空间

# 线程的各组成部分

## 线程栈：

- 工人的工位,是线程工作的地方
- 线程所需要的资源在线程栈中分配
- Windows下线程栈大小默认1M(1024K);
- 线程栈是私有的空间,每个线程独享一个线程栈空间
- 线程堆是公有的空间,

## 内核对象：

- 工厂的领导层,接受老板(操作系统)的指令,管理工人(线程)
- 由操作系统所定义的对象
- 操作系统通过内核对象一管理线程

### 计数器:

- 计数器初始值为2
- 为0时清空线程中所有资源
- 关闭句柄-1
- 线程退出-1

### 挂起计数器:

- 每当挂起一次计数器+1
- 恢复运行一次计数器-1
- 挂起和恢复运行应是等量的

### 信号:

- 判断线程是否有信号,有信号则代表线程已经退出

# 线程的几种基本状态:

- 运行态:
    - 时间片用尽时转为就绪态，等待IO操作转为阻塞态
- 阻塞态:
    - （阻塞时间经过）IO操作已经发生或等待超时转为就绪态
- 就绪态:
    - 就绪队列获得CPU时间片转为运行态
- 死亡态:
    - 进程被杀死,终止运行

## 线程状态的互相转化:

- 就绪态转换为运行态:
    - 线程获得CPU的时间片后;
- 运行态转换为就绪态:
    - 线程的时间片用完了;
- 运行态转换为阻塞态:
    - 程序运行至等待IO操作步骤时;
- 阻塞态转换为就绪态:
    - 发生所等待的IO操作或超时后;
- 阻塞态转换为运行态:不可能发生
- 就绪态转换为阻塞态:不可能发生

# 对线程的几种操作

## (睡眠)Sleep函数:

- 令当前线程睡一定毫秒(ms),时间过后,线程接收到时间片继续工作

## (恢复)ResumeThread函数:

- 将挂起的线程继续运行
- 传入线程句柄作为参数

## (挂起)SuspendThread函数:

- 将运行的线程挂起
- 传入线程句柄作为参数

## 退出线程:

### 正常退出线程

- 线程函数进行到return 0语句时,线程正常退出
- 循环条件退出线程,将线程工作函数的循环条件设定为一个bool变量
    - 改变bool变量的值进而使线程正常退出
    - 退出按钮中修改
- 正常退出时需要**关闭线程句柄**并将**线程句柄置空**
    - CloseHandle();

### 强制退出线程:

- 若线程被挂起(人为/非人为)时,仅通过修改线程循环变量的方式不能使得线程退出
- TerminateThread(m_hThread,-1);
- 强制杀死进程仍然需要关闭句柄并将句柄置空;

### 注意:

- 强制杀死线程可能会导致内存泄漏

### 综合运用两种退出线程的方法:

- 线程能正常退出的时候正常退,不能正常退出时直接杀死
- 如何判断线程是否能够正常退出
    - 定义变量判断
    - 判断线程退出码
    - 使用信号
        - 判断线程是否有信号,有信号则代表线程已经退出
        - WaitForSingleObject

# 两种创建线程函数的区别:

## CreateThread()

Win32 API 中创建线程的函数;

## _beginthreadex()

- C++ 运行库中的创建线程函数
- 是CreateThread()的二次封装;
- 能对C++ 运行库中一些函数所使用的全局变量进行兼容,使得每个线程都有一份独立的“全局”量,保证程序安全性;
- 使用_exithreadex()销毁线程

## 注意:

- 若项目中只调用 Win32 API/SDK ,就放心用 CreateThread;
- 若项目中要使用C++ 库函数，那么就要使用 _beginthreadex ,并需要在编译环境中选择 Use ultiThread Lib/DLL。

创建的线程如果没有C/C++运行时库函数,会自动创建内存块X 结束时若以正常形式退出，内存块不会被销毁，内存泄漏

# 进程线程区别:

## 所属空间:

- 进程中有独立的内存空间
- 线程属于进程的一部分

## 被分配的资源

- 线程是分配CPU单位
- 进程是分配系统资源的单位

# MFC相关操作

## 更改按钮上所显示的字符串:

- 添加按钮后直接打字即可

## MFC中点击按钮实质：

- 向操作系统发送消息 操作系统中将消息放入消息队列中 分配到每一个应用程序的消息？？操作流程

线程分块管理 Postmessage消息流程 系统消息队列—>线程消息队列—->getmessage()消息循环拿到消息—–>翻译—–>分发——>消息发送至回调函数—–>处理 MFC中仅一个回调函数

Sendmessage 系统消息队列—>消息入口点–》指定窗口—》处理函数 消息映射表实质结构体数组 查找找消息映射表的过程即为遍历结构体数组

## 进度条控件：

- 对进度条控件添加变量以创键对象,并通过对象调用函数;
- 进度条控件对象属于CProcessCtrl类
- 选用多字节库运行效果更明显
    - Unicode库对所编译的程序界面存在优化,多字节库无优化
- 设定进度条走过110,而进度条最大值被设置为100时,进度条会先走满一次,在从0开始走10的位置

### 有关进度条的重要函数

- SetRange(); 设定进度条流动范围
    - 默认从最小值流到最大值
    - 进度条最小值为0，最大值为100
- SetPos(int); 使进度条向前走,并设定进度条走到的最终位置
    - 参数表示最终位置
    - 配套for循环向前移动
- StepIt(); 使进度条向前走,调用一次进度条走一点
    - 需要与SetStep()配合使用,或使用默认步长
- SetStep(); 设置步长的函数,默认一次走10点
- OffsetPos();

### 注意:

- 想移动窗口的同时也使进度条向前走,使用多线程

调用windows函数需要加：： 调用MFC函数不需要

GetMessage（）获取消息函数 TranslateMessage（）翻译消息函数 DispatchMessage（）分发消息函数 运行时鼠标在移动时进度条才发送消息

Getmessage为阻塞函数 有消息时才。。。

可使用peekmessage 跑太快时可以加sleep走一步停几秒

1）线程栈：局部，临时资源 2）内核对象

1024字节=1KB 1024KB=1GB 1024GB=1TB

挂起和恢复是有计数的

表示正常退出（线程函数有返回值） 此时进程已结束，但进程句柄仍残留

想要退出进程后点击go能再次生成一条进程

强制退出进程：任何情况都可退出，但不安全 内存泄漏 TerminateThread（）

挂起计数器最小值为0，不为负数

并行 线程1，2均为1 D 并发 线程1快 C 线程2快 B

不是线程越多效率越高

希望他能自己安全退出 如果退不出去，杀死 如何做： 1）判断线程的退出码如果为0，正常退出 2）设置变量判断 内核对象中有信号，创建后无信号，推出后有信号 判断信号函数WaitForSingleObject（） 参数为句柄和等待时间 如果超出等待时间判断是否还在，在，杀死

返回值

当计数器减为0时？？ 线程退出后线程栈被销毁

创建线程后立刻关闭线程句柄，线程仍然在 句柄京用于操作线程 每个线程仅有一个线程栈

线程销毁后不会影响堆区变量 线程堆是共有的，线程栈是私有的

创建一个新进程（建一个新项目） 在新项目中将判断销毁线程变量为销毁 原线程不会被销毁

通过另一进程修改原进程使其线程退出 需要===事件

正常退出后将信号。。。 初始化函数中创建无信号时间 分析CreateEvent函数 参数 安全属性 True为人工事件false为自动事件 False表无信号 事件名（内核空间中仅此一个名字） LI

；ing一个进程中：

人工的五信号时间

就绪运行可互相转化 阻塞只能转化为就绪 运行只能转化为阻塞

C

C

ABCD

通过变量操作终止快 通过事件操作更安全

定义一个全局变量a=0 两线程执行100次a++； 求最后a的最大值和最小值 2 ，200

内存中初值为0 当A线程执行98次 另一条阻塞未执行

覆盖

练习项目 主线程用于显示 新线程用于计算值

值由主线程先传入新线程中 在新线程中计算 再将值传回主线程以显示

10.10.2019

不运算时如何解决占用很多CPU问题（进程未停止所导致） 挂起或恢复 Sleep只是暂停当时间流过后仍占用较多CPU 阻塞–事件实现 挂起或恢复 创建线程时即挂起（参数修改） 运算后释放 点击按钮后释放 阻塞 定义一个事件句柄 创建一个无信号自动事件（人工也可以但用过之后要置为空） 构造函数中初始化句柄 调用create 计算前等待事件信号消息 WaitForSingleObject（INFINITE） 再按下按钮后 最后结束时要关闭句柄 一些优化 1）解决三个点选空间函数冗余问题 相同控件可分组 格式中有Tab键 讲一个点选控件属性中group改为true 与之相邻相同按钮即为一组 点选控件添加变量为Value 值未被赋给控件 在Dodataexchange函数中会将点选控件变量的值初始为》》AA 经过所有的变量 建立新的按钮 在按钮的功能函数中调用UpdateData函数 UpdateData函数的参数 TRUE:获取数据放入添加的点选控件变量中 （确定选择了哪一个控件） FALSE:将值初始化到窗口上 通过switch判断点选控件变量的值 Case的值的顺序由格式中的Tab键顺序决定 Switch结束后设定信号事件

2）如果不使用stewindowtest函数 采用窗口发送消息函数sendmessage（） 添加消息映射函数 添加消息映射表的宏 返回值