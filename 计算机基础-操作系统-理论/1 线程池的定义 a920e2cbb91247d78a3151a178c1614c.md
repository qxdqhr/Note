# 1.线程池的定义

# 线程池：

## 线程池的定义:

- 预先创建一些线程,创建时使这些线程处于睡眠状态;不占用CPU
- 创建线程的数量约等于CPU核数的2倍
- 当线程池接收到任务时,唤醒睡眠的线程开始工作;
- 线程池可以保存多个线程有任务时所有线程开始工作，没有任务时就不工作

### 让线程不占用CPU资源的几种方法

- 挂起(点名工作)
    - 可以实现
    - 接收到任务时,指定某一线程开始工作
- 阻塞 (随机指定工作)(较为简单)
    - 可以实现,令线程等待1个内核对象就可实现阻塞
    - 接收到任务时,随机指定任一线程开始工作
- 睡眠:sleep()
    - 不可实现

## 线程池的作用

提高线程 多线程的作用：提高效率 对于计算机，何时为效率最高状态 线程的工作：轮换时间片操作 切换线程需消耗时间 四核计算机：4条线程同时工作效率最高

来任务时就唤醒线程： 挂起：释放 阻塞：对应释放 睡眠：无特定操作

随机线程，：阻塞（事件，信号量，互斥量）TODO 挂起需要指明特定线程

## 实现一个线程池：

### 定义一个线程池的类：ThreadPool

### 功能：

1. 创建一些线程：均阻塞于线程函数,等待信号量
2. 销毁线程
3. 线程函数：取得任务，接收到信号量时,执行任务
4. 投递任务

### 大体流程:

1. 创建一些线程,
2. 所有线程都阻塞在线程函数之前
3. 当来客人时,释放一个信号
4. 当一个线程接收到信号后,此线程开始工作
5. 所有任务结束时销毁线程池

### 一些问题:

- 投递任务函数中接到任务的数据变量属于局部变量,离开作用域后会销毁
    - 将变量定义为类成员
- 传入参数类型不确定
    - 直接传入结构体,Node* 存一个成员NODE,只传入node即可
- 传入参数个数不确定
    - 使用类模板,来一个父类,使用父类指针,传入父类指针操作对应的子类
- 投递任务很快，会导致1号任务投递之后2号任务被 先到的任务先执行，设定任务队列 接收任务函数直接从队列中取得任务

任务的操作：加法还是乘法（仅传递了值） 类中封装一个接口 父类中如何调用子类接口函数：重写虚函数 父类中添加一个接口 用于操作数据结构体和

## 项目的实现:

创建Win32项目

### 任务类：

构造

虚析构

运行任务的虚函数

### 线程池类：

包含成员:

- 链表<list>
    - 句柄链表：线程句柄Handle为WINDOWS.h创建的线程存在链表中
- 信号量
- 队列<queue>
    - 任务队列,存储元素类型为任务类
- 标记变量:
    - 用于终止线程工作
- 创建线程的个数
- 最多同时工作的线程数量
- 运行的线程个数

包含函数:

- 创建线程池函数
    - 线程最小值
    - 线程最大值
- 销毁线程函数
    - 从帮助文档中的_beginThread（）中获取线程函数的返回值
- 线程工作函数（void*）
- 投递任务函数(任务类指针)

### 线程池各函数:

### 构造函数:

### 创建线程池函数:

1. 应考虑传入函数参数的正确性,加入错误判断
2. 创建线程之前创建信号量
    1. CreateSemaphore()
    2. 最开始没有任务，释放0个信号
    3. 也可以创建在构造函数中
3. 创建最小值条线程（循环进行最小线程数次），
4. 每当线程创建成功，将当前线程压入线程队列

### 线程函数:

1. 强转线程参数为本类指针
2. 在类中添加标记成员变量作为循环条件（需使用本类指针调用）
3. 等待投递函数所释放的信号量
    1. 等到信号量，进入任务队列取任务
    2. 最开始所有线程均被设为阻塞状态
    3. WaitForSingleObject()
        1. 时间设为INFINITE,表持续阻塞
4. 接收信号量后,判断队列是否为空
    1. 不为空则取出任务,并弹出队头
5. 执行取出的任务
    1. 调用RunTask函数
6. 任务执行过后,删除任务对象

### 线程销毁函数:

1. 将退出标记变量置为空
2. 设定线程链表迭代器并遍历关闭线程
3. 遍历中判断任意线程是否超时
    1. WaitForSingleObject(object,time);
        1. 超时:WAIT_TIMEOUT
    2. 超时则直接终止此线程
        1. TerminateThread(thread,-1);
4. 遍历结束后清空线程链表
    1. clear()
5. 结束时关闭信号量的句柄
6. 循环清空任务队列

### 投递任务函数:

1. 将参数进行有效校验
2. 将任务加入队列中
3. 释放信号量
    1. ReleaseSemaphore(信号量,个数,)

### 注意:

线程数量与线程工作的问题

1. 有空闲线程,接收到信号量,开始工作
    1. 条件:
        - 运行的线程数小于正在工作的线程数
    2. 操作:
        - 释放1个信号量
2. 无空闲线程,但未达到上限
    1. 条件:
        - 运行的线程数等于正在工作的线程数 && 创建线程个数小于总(最大)线程数
    2. 操作:
        1. 创建新线程
        2. 将新线程加入线程链表中
        3. 释放1个信号量
3. 无空闲线程,已经达到上限
    1. 条件:
    2. 操作:
        - 释放一个信号量

### 测试线程池

1. 需要建立子类继承任务类
2. 主函数创建线程池类以及任务类对象
3. 

![https://www.notion.so1.%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%AE%9A%E4%B9%89.assets/image-20201018144917893.png](https://www.notion.so1.%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%AE%9A%E4%B9%89.assets/image-20201018144917893.png)

image-20201018144917893

### 注意:

1. 创建线程的个数
    1. 不是县城越多工作效率越大
2. 解决线程池中的线程并发问题
    1. STL不支持多线程
3. 尽量避免内存泄漏问题
    1. 内存资源泄露
    2. 线程资源泄露
4. 死锁问题
    1. 两个及以上的线程在竞争资源时产生的僵持的现象,若无外力作用,无法推进
    2. 产生原因:
        1. 资源不足
        2. 线程推进顺序不当
    3. 避免死锁的方法
        1. 银行家算法
    4. 解决死锁的方法

试

假设创建了100根线程

直接崩溃 原因： 调试窗口-调用堆栈-找到自己写的代码-崩溃出现的地方 多线程并发问题—加锁：关键段

使用互斥量

创建线程池的时候把互斥量也创建出来

锁在哪里

此时仍出现错误 什么问题 判断被设定在了外面 所以在里面也设定判断

此时仍未单线程 将执行函数放在外面

还会崩溃 中断，调用堆栈，查看崩溃的地方 STL队列中的队列不支持多线程访问 不允许投递的时候再向外取任务 （push的时候不能pop） 加上所之后，其他人就不能向里进 如何加锁

进程有大小限制 所以线程也有大小限制 所以线程数有上限 理论最大能创建2000多条线程 但进程中还要存储代码等文件 1500多条就会崩

任务执行完成后要删除线程

用过线程之后要将线程移出线程栈

注意： 创建一些线程，具体个数，CPU有关，业务有关，效率不一定会提高 2. 3.多线程同时访问统一数据会有并发问题， 创建的所有线程要释放 优化点：可以根据任务量销毁线程（任务多线程多，任务少线程少，线程数可变） push和pop不能同时实现，自己实现队列，底层数据结构：链表：便于增删改查 数组：查询效率高：空间换时间，可使用数组 开辟级大数组环形缓冲区 效率优于链表

线程池完结。