# 虚函数:
# 虚函数与多态
## 原理:函数指针完成
#include<iostream>
using
# 虚函数的实际运行方式
18.20
当创建
若AA是一个虚函数

调用子类的多个函数时,每一个函数都需要一个函数指针,使用函数指针数组存储,对于B类有一套指针数组,对于C类也有一套指针数组,调用某一类中的函数,vfptr
根据创建的对象决定使用哪一个类的列表,vfptr决定
实际调用时适用对象地址传入,调用对应对象的vfptr中的某一根指针,即可调用对应函数

函数类型不同时会将函数地址转换为同一类型



虚函数通过重写函数实现多态
具体重写时,子类中重写函数的 virtual 关键字可以省略,但父类中的虚函数一定要加关键字;
出现子类的子类时,一级子类中18.36

## 各类中的虚函数列表:
每个类中仅有一个虚函数列表
### 父类中虚函数列表:
父类AA函数
父类BB函数
#### 注意:
此时CC函数
### 一级子类的虚函数列表:
继承过来父类已有的虚函数列表;
此时一级子类中以重写AA函数,
一级子类的AA函数
父类BB函数

18.40
父类指针不可调用子类中独有的虚函数

18.41
19.00

创建堆区对象,使用一个指针存储对象的地址
VFPTR对象首地址的前四个字节
数组是函数指针的指针数组
所以VFPTR应是一个二级指针,在调用时应使用**p的方式


调用VFPTR:
先将其强转为一个指向int类型的指针,int为4字节
*(int*)pFather
但函数指针不允许函数指针偏移,因为函数所占有几个字节不确定;
将这个地址整形指针,整形指针可以偏移
Vfptr中的四个成员:(虚函数列表中的四个成员)
*((int*)*(int*)pFather+0)
*((int*)*(int*)pFather+1)
*((int*)*(int*)pFather+2)
*((int*)*(int*)pFather+3)
这些地址就是四个函数的地址,但这些地址不应调用(无对象)