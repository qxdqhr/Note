# 5.Linux文件系统

文件系统： 概述： 1.是操作系统对电脑文件的管理方式(文件的放入和取出) 2.一个磁盘中的任一分区必须被格式化成一种文件系统后才能存储文件 3.格式化的过程会在磁盘上写一些管理存储布局的信息 4.块：（Block） 文件系统中存储的最小单位， 大小是在格式化时确定， mke2fs的-b选项可以设定块大小为1024、2048或4096字节。 5.启动块（Boot Block） 用来存储磁盘分区信息和启动信息 启动块是由PC标准规定的 大小是确定的1KB， 任何文件系统都不能使用启动块 启动块不属于任何一个块组，也不属于文件系统 启动块之后才是文件系统的开始

```
不同的格式化类型：
    Windows 下
        NTFS    ：对单文件无大小限制
        FAT32   ：不允许单独文件大小超过4G
        exFAT   ：
        其他文件系统
    Linux 下
        ext2    ：早期文件系统
        ext3    ：
        ext4    ：与ext2仅存在（文件大小）？区别
       其他文件系统

文件系统是如何管理系统中文件的：
    初始目的：能够将文件正确存放，并且要使用某一文件时能够正确找到
        初始文件系统结构：(图书馆举例：位置标签 + 具体图书)
            文件内容所占空间  +   文件地址所占空间(与文件内容为映射关系)
            通过寻找文件地址能够找到对应文件，存在一种映射关系
        初始文件系统结构的缺点：
            文件A大小可变时(编辑文档，文档所占空间变大)
            （若AB地址连续） 地址存储在文件A之后的文件B内容被覆盖
        对基本模式缺点的分析：
            由于文件大小可变，文件系统中可能存在
                1）文件太大，存不进去
                2）文件太小，浪费空间

Linux下的ext系列文件系统（ext2,ext3,ext4）
    1.ext系列文件系统的构成：
        ext2文件系统将整个分区划成若干个同样大小的块组（Block Group）
        不同块组以标号进行区分：Block Group 0；Block Group 1..
        每个块组都由以下部分组成：

            1.超级块（Super Block）
                描述整个分区的文件系统信息，
                例如块大小、文件系统版本号、上次mount的时间等等。
                超级块位于每个块组的开头
                且所有的超级块都是同一个超级块的拷贝。

            2.块组描述符表（GDT，Group Descriptor Table）
                由很多块组描述符组成，
                整个分区分成多少个块组就对应有多少个块组描述符。
                每个块组描述符（Group Descriptor）存储一个块组的描述信息，
                    例如在这个块组中    inode表的位置 数据块的位置 空闲的inode和数据块数量等。
                块组描述符表位于超级块之后
                且所有的块组描述符表都是同一个块组描述符表的拷贝

                多份拷贝的原因：
                    块组描述符或超级块意外损坏就会丢失整个分区的数据，
                    通常内核只用到第0个块组中的拷贝，
                e2fsck命令：检查文件系统是否正常工作
                第0个块组中的超级块和块组描述符表就会拷贝到其它块组
                这样当第0个块组的开头意外损坏时就可以用其它拷贝来恢复，
                从而减少损失。

            3.块位图（Block Bitmap）
                本质上仍是一个块（占有4096字节的空间）
                用于标记当前块组内的所有快的使用情况
                表示原理：
                    利用与Bitmap算法相似原理
                    根据快位图的大小（4096 Byte）
                    确定一共能表示多大的位空间=4096*8=32768位
                    在这些位空间中
                    1所表示的位 表明对应的块已被使用
                    0所表示的位 表明对应的块未被使用，该块空闲可用

            4.inode位图（inode Bitmap）
                和块位图类似，本身占一个块，
                用于标记当前块组内的所有inode的使用情况
                其中每个bit表示一个 inode是否空闲可用。

            inode表（inode Table）
            一个文件除了数据需要存储之外
            一些描述信息也需要存储，例如文件类型（常规、目录、符号链接等）
            ，权限，文件大小，创建/修改/访问时间等，
            也就是ls -l命令看到的那些信息，
            这些信息存在inode中而不是数据块中。
            每个文件都有一个inode，
            一个块组中的所有inode组成了inode表。
            inode表占多少个块在格式化时就要决定并写入块组描述符中，
            mke2fs格式化工具的默认策略是一个块组有多少个8KB就分配多少个inode。
            由于数据块占了整个块组的绝大部分，
            也可以近似认为数据块有多少个8KB就分配多少个inode，
            换句话说，如果平均每个文件的大小是8KB，
            当分区存满的时候inode表会得到比较充分的利用，
            数据块也不浪费。如果这个分区存的都是很大的文件（比如电影），
            则数据块用完的时候inode会有一些浪费，
            如果这个分区存的都是很小的文件（比如源代码），
            则有可能数据块还没用完inode就已经用完了，
            数据块可能有很大的浪费。
            如果用户在格式化时能够对这个分区以后要存储的文件大小做一个预测，
            也可以用mke2fs的-i参数手动指定每多少个字节分配一个inode。
```

数据块（Data Block）根据不同的文件类型有以下几种情况 1.对于常规文件，文件的数据存储在数据块中。 2.对于目录，该目录下的所有文件名和目录名存储在数据块中，注意文件名保存在它所在目录的数据块中，除文件名之外，ls -l命令看到的其它信息都保存在该文件的inode中。注意这个概念：目录也是一种文件，是一种特殊类型的文件。 3.对于符号链接，如果目标路径名较短则直接保存在inode中以便更快地查找，如果目标路径名较长则分配一个数据块来保存。

设备文件、FIFO和socket等特殊文件没有数据块，设备文件的主设备号和次设备号保存在inode中。

一个块组中的块是这样利用的： 数据块 存储所有文件的数据， 超级块、块组描述符表、块位图、inode位图、inode表这几部分
存储该块组的描述信息。 数据块中 若某分区的块大小是1024字节，某个文件是2049字节， 则需要三个数据块来存， 即使第三个块只存了一个字节也需要占用一个整块；

为什么用df命令统计整个磁盘的已用空间非常快呢？ df命令查看每个块组的块位图，而不需要搜遍整个分区。 相反，用du命令查看一个较大目录的已用空间就非常慢， 因为不可避免地要搜遍整个目录的所有文件。

在格式化一个分区时究竟会划出多少个块组呢？ 主要的限制在于块位图本身必须只占一个块。（快位图的大小决定块组中一共有多少个块空间） 用mke2fs格式化时默认块大小是1024字节， 可以用-b参数指定块大小，现在设块大小指定为b字节， 那么一个块可以有8b个bit，这样大小的一个块位图就可以表示8b个块的占用情况， 因此一个块组最多可以有8b个块，如果整个分区有s个块，那么就可以有s/(8b)个块组 。格式化时可以用-g参数指定一个块组有多少个块，但是通常不需要手动指定， mke2fs工具会计算出最优的数值。

文件系统第三方函数 1

文件系统：一部分空间存文件，另一部分存文件地址 linux特有文件系统格式：ext2 扇区：大小的一个单位 大小为512字节的一个空间 块block：ext2基本操作单元 大小4096个字节 block group 0 块组0 bootblock 大小为1024字节=1kb独立于所有文件系统（所有文件系统均含有此空间） 用于存磁盘信息和启动空间，用于启动 分为① super block 超级块 存储基本信息 ② GDT 当前块组内起始，剩余块组，及一些信息 ③block bitmap 块位图（位图算法：使用二进制数表示某物件的状态） 32768位=4096大小*8字节 当前对应块组中各块的使用情况 ④inode btimap 表示 inode的使用情况 ⑤inode table inode表 一个文件仅能有一个inode inode中存①文件信息 ②15个指针，指向对应数据块，一指一 一级间接寻址： 一指针只想一个数据块 数据块中不存储数据存储指向另外一段空间（实现扩容） 二级间接寻址： 指针A指一个数据块存储指针a1.。。 a1.。。an每个再指向每段空间都存储指针 a1‘ a1’ 再指向一段空间 ⑥ Data block 存储文件区 拿出文件操作过程 根目录编号为2 编号为1的是初始化init

文件描述符的分配原则 找当前文件描述符中找未被分配的且值最小的文件描述符

删除文件快的原因： 删除过程，先找到对应inode号 直接找到对应指向数据的指针，赋为空 两个bitmap中对应文件值0置为1 重新添加文件时已被删除的文件会被新文件覆盖 动态算法 一个块组不够可以跨到另一个块组 块组大小基本固定

记录项存在的文件类型

stat +文件名 、