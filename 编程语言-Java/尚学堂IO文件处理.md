IO 的具体应用：文件下载/上传
IO 的实质：本机和用户/ 服务器的交流 
1）什么是IO？
2）IO要做什么？
操作File文件，即数据源。
何为数据源？
存储数据的源头，单个文件，数据库，网络，其他电脑内存，键盘鼠标的操作信息
3）字节流：直接操作字节所形成的流
字节：在计算机中所存储的二进制数据（0，1），被称为字节。
4）字符流：直接操作字符所形成的流
5）CommonsIO ：被用于操作文件流的组件，可用于简化文件操作过程，提高效率
关于组件：程序员的主要工作是要将客户的需求转化为代码要侧重于高效的实现功能，而不要侧重于技术的实现，即不要重复造轮子。


1）IO概述
IO流是一个动态抽象的概念，是一连串连续动态的数据的集合。即，数据流。
流：流动，从一端流动至另一端（从数据源流动至程序），从程序到数据源之间所形成的一条桥梁被称为IO流。
数据源：是提供原始数据的原始媒介。
对于流的主体，我们要以程序作为中心（数据从文件流入程序中，再从程序流出至文件）
由此，形成了输入流和输出流
以读书这种行为作为类比：
读书的过程，将书中的内容（数据源中数据）以流的形式，流入（输入）至大脑（程序）中。
写的过程，将大脑（程序）中的内容（数据源中数据），以流的形式，写（输出）在纸上。
数据从文件进来为输入流
数据从程序流向文件为输出流
有关IO操作的类与接口

关闭流接口：
文件存储在硬盘上，硬盘被操作系统控制，当JAVA程序结束文件操作时，应通知操作系统操作结束，并释放对应的系统资源。
刷新流接口：
当有些数据驻留在文件流中时，应对文件流进行强制刷新，刷新掉驻留数据
序列化接口：
将对象的数据存储至文件中，以便保存对象，需要进行对象的序列化，从文件中读取对象的时候需要进行反序列化操作。
IO流的分类：
1）按照流向分类(以程序为中心)
输入流：数据源到程序（使用InputStream、Reader以读取数据）
输出流：从程序到目标数据源（OutputStream、Writer以写出数据）
如图所示：

读入端程序与读出端程序为同一程序时，可实现对文件内容的操作（拷贝,加密,上传下载）。
2）按照功能分类:(如何操作数据源)
直接操作数据源：
节点流：可以直接从数据源或目的地读写数据
此处节点为存储节点/网络节点
间接操作数据源：
对节点流进行二次封装，以简化操作并且提升性能，形成
处理流（包装流）：不直接连接到数据源或目的地，是其他流所进行的封装。
使用了设计模式中装饰设计模式（对某事物进行美化）
节点流和处理流之间的关系：
节点流始终处于IO操作的第一线，任何IO操作都必须通过节点流进行。
没有节点流就没有处理流，处理流是节点流的二次封装。
3）按照所操作的数据分类：
字节流：对字节型数据进行操作的流（InputStream、OutputStream）
字符流：对字符型数据进行操作的流（Reader,Writer）
字符流的本质：底层基于字节流的操作，通过搜寻指定的字符编码表
根据程序的编码方式的不同，所有字符被划分成许多种字符集
（每个字符集对应各自的编码方式）
常见的字符集举例（编码方式）：GBK,UTF8,Unicode等。。
程序的编码方式必须对应其相应的字符集，否则会出现乱码错误。（编码不通）


















二、IO包下的File类

File类概述
使用File类进行对文件，文件夹，数据源的封装抽象表示
计算机中文件存储在硬盘上，JAVA程序只能通过JAVA虚拟机向操作系统发送文件操作的消息，继而操作硬盘中文件
使用的FILE类是JAVA程序与本机操作系统之间建立的一种联系。
对于File类，其指代的可以是文件夹、文件、空文件、不存在的文件。
File是文件的抽象的表示形式。
（FILE类构建完成并不意味着对文件的操作已经完成）

File的使用（常用API）及文件的编码

JAVA中的API使用
在API中查找到类后，要查看：
1）此类的继承体系：查看父类/接口
2）此类的说明：看着此类具体是干什么的
3）此类中用于操作的常量
4）此类的构造器（任何一个类都有一个构造器）
有构造器：可以创建对象调用类成员函数。
无构造器：通过类的类型确定如何调用类成员函数。并调用。
构造器在API文档中未显示的原因：
1）	此类是一个工具类，不需要对象，也就不需要构造器。
使用此类时，可直接通过调用类成员方法进行使用。
其中包含的类方法多为静态方法。
eg：math类
2）	此类的对象是由本类中静态方法来创建。
调用静态方法创建并返回对象。
即，可以通过类中的的静态方法来得到此类的对象，
进而通过对象进行成员方法的调用。
eg：Runtime类
（获取对象函数getRuntime()底层实现使用单例设计模式）
5）此类包含的成员方法：
1）（叫啥）名称
2）（传啥参数）参数（形参）
3）（能干啥）功能
4）（能得到啥）返回值
5）（怎么用）如何使用（静态/类成员）











FILE类：
用于操作的常量：以separator为例
系统的路径分隔符：separator
不同操作系统中的路径分隔符是不同的
跨平台使用时，可能会报错
eg：目标：在temp目录下建立一个test.txt文件
Windows：	File file1 = new File ("C:\tmp\test.txt");
Linux：	File file2 = new File ("/tmp/test.txt");
为确保拼接出的路径字符串不会跨平台报错，使用如下方式：
File myFile = new File("C:"+File.separator+"tmp"+File.separator,"test.txt");
开发过程中基本都使用拼接字符串来形成路径
Java 在 UNIX 和 Windows 自动按约定分辨文件路径分隔符。
如果你在 Windows 版本的 Java 中使用分隔符 (/) ，路径依然能够被正确解析。


构造器：
常用三种构造器：
File src = new 构造器；
1）File(String 对应操作文件的文件路径)
2）File(String 父文件夹路径, String 子文件夹路径) 
两个字符串可以拼接成目标文件的路径即可
3）File(File 父文件对象, String 子文件夹路径) 
父文件对象：将2）中的父文件路径通过一个构造器对象化


包含的成员方法：（需要通过对象调用）
1）getAbsolutePath（）：获取当前文件的绝对路径
相对路径：路径中没有盘符（Windows），相对于当前目录
绝对路径：路径中有盘符（Windows）
eg：哈理工在哪里？	相对：学府三道街。。。
绝对：中国，黑龙江省，哈尔滨市，南岗区，学府三道街。。。

2）length（）：仅能获取文件的大小，返回值为long
返回值为0时：1）不存在目标文件2）目标文件是一个文件夹
3）	getName（）：获取文件名函数，返回文件名的字符串
getPath（）：获取文件的路径，绝对相对均可，由向构造器中传入的路径决定
getAbsolutePath（）：获取文件的绝对路径，无视向构造器中传入的路径。
getParent（）：返回父路径名
将向构造器中传入的路径中目标文件的全部上级文件路径返回
（从目标文件名的前一个文件名分隔符开始算起向前全部）
若传入相对路径，则返回null
getParentFile（）：返回父文件对象，可以通过此函数的返回值再次调用成员函数
4)	createNewFile（）：	不存在文件才创建返回true，存在文件则不创建返回false
创建文件时不带后缀名并不能创建文件夹，仅创建了一个没有后缀名的文件
delete（）：	删除当前File对象所指代的文件。
补充：
创建文件时不能使用con的文件名（此文件为操作系统的关键字，创建时则会失败）

5）创建文件夹
