# C和C++区别

# C++面向对象的特征

# C++中的类型安全功能

1. 操作符new返回的指针类型严格与对象匹配，而不是void*；
2. C中很多以void*为参数的函数可以改写为C++模板函数，而模板是支持类型检查的；
3. 引入const关键字代替#define 
4. inline函数，结合函数的重载，可在类型安全的前提下支持多种类型，当然改写为模板也能保证类型安全；
5. C++提供**static_cast、dynamic_cast、const_cast、reinterpret_cast**关键字

# C++中的引用和指针的区别 

1. 指针有自己空间，引用是一个别名；
2. sizeof指针的大小是4，sizeof引用是被引用对象的大小；
3. 有空指针没有空引用；
4. 传参时,指针通过间接引用操作对象，修改引用会改变引用所指向的对象；
5. 可以有const指针，但是没有const引用；
6. 指针可指向其它对象，引用只能是一个对象的引用，不能修改；
7. 有多级指针，无多级引用；
8. 指针和引用使用++运算符的意义不同；
9. 作为返回值必须使用指针，引用可能引起内存泄露。

# new delete malloc free 的区别

1. new、delete是C++中的操作符，而malloc和free是标准库函数。
2. malloc free不能自动调用构造函数和析构函数,仅分配和释放内存。new delete可自动调用构造函数和析构函数并初始化对象。
3. new返回指定类型的指针，可自动计算所申请内存的大小。 malloc返回void类型指针,需强转,并手动计算申请内存的大小。

# stl set和map

- 相同点:
  -  都是一种关联式容器
  - 都以RBTree作为底层容器
  - 都不允许键值重复
  - 都是通过键对所有元素进行自动排序
  - 键值都不可修改
- 不同点:
  - map所有元素都是键+值存在,set元素的value就是key
  - map的键对应的值是可修改的,set的值就是键,不能通过迭代器来改变

# 红黑树有什么操作

左旋,右旋,变色,插入删除

# C++中class和struct的区别  

- 相同点:
  - 可包含成员变量和函数。
  - 可被继承
- 不同点:
  - class 中的成员默认都是 private 属性； struct中的成员默认都是 public 属性。
  - class 继承默认是 private 继承，而 struct 继承默认是 public 继承
  - class 可以使用模板，而 struct 不能

# C++11 

## auto关键字:

- 用于自动类型推导。编译器会在编译期自动推导出变量的类型，不用手动指明变量的数据类型。
- 等号右的表达式是引用类型时，auto 会把引用抛弃，直接推导出其原始类型。
- 变量不是引用，auto 将丢弃原表达式的 const；变量是引用，auto 将保留原表达式的 const 
-  auto 不能用于函数参数。
- auto 不能用于类的非静态成员变量（无 static 修饰的成员变量）
- auto 不能定义数组
- auto 不能用于模板参数

# C++智能指针 auto_ptr还有吗 是被 share_ptr替代了吗?

auto_ptr是C++98标准库提供的一个智能指针，但已被C++11明确声明不再支持。

# EPOLL底层函数执行步骤

# Select,poll,epoll属于哪种模型

# 还有什么网络模型

# Mysql怎么优化

# Mysql的引擎有什么

# MyISAM和Innodb的区别

# MyISAM支持事务吗

# 查询语句怎么优化

# 视图中有存储数据吗

# Mysql中的锁

# Mysql的四种隔离状态

# Redis有接触过吗 Redis 的 zset

# Redis的持久化

# GET和POST的区别

# POST可以被缓存吗

# 一共有几种请求方法

# session和cookie

- 什么是Cookie与Session
  - Cookie与Session用来**跟踪用户的整个会话**,是常用的会话跟踪技术。
  - 一个用户的所有请求操作都应该属于同一个会话，而另一个用户的所有请求操作则应该属于另一个会话，二者不能混淆
- 为什么出现会话跟踪技术
  - Web应用程序是使用HTTP协议传输数据
  - HTTP协议是无状态的协议。每次数据交换完毕，客户端与服务器端的连接就会关闭，再次交换数据需要建立新的连接。因此服务器无法从连接上跟踪会话

Cookie通过在客户端记录信息确定用户身份

Session通过在服务器端记录信息确定用户身份

1. cookie数据存放在客户的浏览器上，session数据放在服务器上.

 简单的说，当你登录一个网站的时候，如果web服务器端使用的是session,那么所有的数据都保存在服务器上面，

客户端每次请求服务器的时候会发送 当前会话的session_id，服务器根据当前session_id判断相应的用户数据标志，以确定用户是否登录，或具有某种权限。

由于数据是存储在服务器 上面，所以你不能伪造，但是如果你能够获取某个登录用户的session_id，用特殊的浏览器伪造该用户的请求也是能够成功的。

session_id是服务器和客户端链接时候随机分配的，一般来说是不会有重复，但如果有大量的并发请求，也不是没有重复的可能性。
Session是由应用服务器维持的一个服务器端的存储空间，用户在连接服务器时，会由服务器生成一个唯一的SessionID,用该SessionID 为标识符来存取服务器端的Session存储空间。而SessionID这一数据则是保存到客户端，用Cookie保存的，用户提交页面时，会将这一 SessionID提交到服务器端，来存取Session数据。这一过程，是不用开发人员干预的。所以一旦客户端禁用Cookie，那么Session也会失效。

2. cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗考虑到安全应当使用session。

3. 设置cookie时间可以使cookie过期。但是使用session-destory（），我们将会销毁会话。
4. session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能考虑到减轻服务器性能方面，应当使用cookie。
5. 单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。(Session对象没有对存储的数据量的限制，其中可以保存更为复杂的数据类型)

  注意:

   session很容易失效,用户体验很差;

   虽然cookie不安全,但是可以加密 ;

   cookie也分为永久和暂时存在的;

   浏览器 有禁止cookie功能 ,但一般用户都不会设置;

   一定要设置失效时间,要不然浏览器关闭就消失了;

 

   例如:

​      记住密码功能就是使用永久cookie写在客户端电脑，下次登录时，自动将cookie信息附加发送给服务端。

​      application是全局性信息，是所有用户共享的信息，如可以记录有多少用户现在登录过本网站，并把该信息展示个所有用户。

 

 **两者最大的区别在于生存周期，一个是IE启动到IE关闭.(浏览器页面一关 ,session就消失了)，一个是预先设置的生存周期，或永久的保存于本地的文件。(cookie)**

 

Session信息是存放在server端，但session id是存放在client cookie的，当然php的session存放方法是多样化的，这样就算禁用cookie一样可以跟踪

 

Cookie是完全保持在客户端的如：IE firefox 当客户端禁止cookie时将不能再使用

# 

# TCP三次握手的过程

# 三次握手最后一次握手失败了,Linux系统中服务器会进行什么操作

# 四次挥手的过程

# time_wait close_wait

# 常见的http状态码

# 接触过ngix吗

# 排序算法较快的,时间复杂度

# 了解希尔排序吗

# 快排的思想

# 快排平均时间复杂度

# 希尔排序平均时间复杂度

# 单核机器上,多线程程序是否有必要加锁,什么场景下需要加锁 什么场景下不需要加锁

