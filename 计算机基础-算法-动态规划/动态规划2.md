# 动态规划2

重叠子问题:求解过程中一般随着问题规模的增大,问题规模增大

绝对值函数:先减后增,不是单调的,不是一种重叠的子问题

重叠子问题是写出状态转移方程的前提



## 如何完成动态规划问题的代码:

- 递归方式:
  - 直接使用状态转移方程,应用到代码中

- 循环方式:
  - 将结果记录到表中(一维dp,二维dp)
  - 特定情况下可以将数组优化为变量
    - 节省空间
    - 通过变量的移动同样可以解决问题
    - 滚动数组



树形dp一般使用递归的方式求解

一般

要想当前层要干什么,不要想下一层会怎么走,会乱

# 二叉树的万能公式:

遍历二叉树是一个可以用递归求解的问题

```
void fun(Node* root)

{
	//异常判断
	
	//终止条件,边界条件
	
	//逻辑
	
	//递归左
	//递归右


}
```

# 股票买卖的最佳时期

- 分析问题状态:
  - 未交易:0
  - 第一次买入:1
  - 第一次卖出:2
  - 第二次买入:3
  - 第二次卖出:4
- 给定的是数组作为参数
  - dp方程需要从一维升级为二维
  - dp\[i][j]表示 第j种情况下的问题量级为i时的结果
- 问题的需求是求解 max(dp\[n-1][2],dp\[n-1][4])

求解状态转移方程:

- 状态:未交易:0
  - dp\[i][0]=dp\[i-1][0]=0
  - 如果不交易,利润永远是前一天的值,为0
- 状态:第一次买入:1
  - dp\[i][1]=max(dp\[i-1][1],dp\[i][0]-prices[i]);
  - 要求这一状态下的利润最大化,需要分情况
    - 第i次不卖出,利润是前一时段的利润值
    - 第i次卖出,利润=未买入时的的利润值-第i次的股价(均为负数)
- 状态:第一次卖出:2
- 状态:第二次买入:3
- 状态:第二次卖出:4
- 冷却期