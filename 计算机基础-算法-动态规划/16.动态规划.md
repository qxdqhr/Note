# 动态规划Dynamic Programming

- 求最优解每一步都被安排好,规划更长远
- 用空间换取时间的方法
- 对于问题的求解过程不一定是最好的
- 思想:
  - 将一个大问题拆解为一个个小问题,当所有下问题的解都得出后,原问题即有解

## 动态规划的先决条件(什么问题可以使用动态规划问题):

1. 无后效性:
   - 计算子问题的结果时不关心子问题的求解方式
   - 一旦某一情况的元素值已经确定,那么得出此元素的方式即不再被关注(过去不影响将来)
2. 最优子结构性质:
   - 子问题的最优解**能构成**当前问题的最优解的一系列问题

## 动态规划问题的解法

- 自顶向下：
  - 带备忘录，从较大问题的结果往小结果存储
  - 防止计算结果的丢失
- 自底向上：
  - 从小往大存(常用)

## 动态规划的求取核心:状态+状态转移方程

- 状态
  - 子问题的最优解
  - 某一情况下的问题的解
- 状态转移方程
  - 由一个状态转变到另一个状态的通式
  - 求取状态的方程
  - 某一情况的解是从哪一情况中得到的
  - 如何得到下一情况的问题的解的方程

## 动态规划算法与贪心算法的区别:

贪心：仅眼前一步

## 动态规划算法的好处:

- 在计算问题的每一步时,需要使用到**前一状态的解**来得到**当前步骤的解**

- 程序运行时需要将这些过去的最优解进行存储,进而提高了效率;
  - 空间换时间





## 01背包问题

### 问题描述:

有一个包有容量遇到宝石价值不同大小不同如何拿价值最高

## Fibonacci数列:
### 方法1:

先求F50的再向下求F49.。。。。
需要辅助空间
类似于：
自顶向下带备忘

### 方法2:

从F1开始求到F50
类似于
自底向上

动态规划用于求最优解
但所得结果不一定都是最优解
(更优数学方法)

典型使用空间换取时间方法

### 捡苹果问题

地上有m*n个格子,一个人从左上(0,0)向右下移动

问此人如何移动能保证见到的苹果最多?

![image-20201022194543282](16.%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.assets/image-20201022194543282.png)





从较大规模的问题倒序求解:

从终点开始向回求

状态转移方程:

c\[i][j]



Djstra



### LCS最长公共子序列问题

X:BCABDAC

Y:CBBADC





























动态规划(Dynamic Programming)
概念：
        用来求得问题的最优解(最多，最少，最短。。),用于解决的问题被简称为DP问题
        求取最短路径问题
                可以用动态规划的方法解决
                可以用Djsktra算法运用贪心的思想解决问题
动态规划和贪心算法的区别：
        贪心算法：只连续由当前一步的最优解确定最优解，不由整体选项的趋势确定整体是否最优
        贪心算法的缺点：由每一步的最优解可能走进死胡同，无法达到最优解
        动态规划：根据起点到终点的过程中每一步都确定下来，由所有步骤确定整体结果最优；
        动态规划过程中的所有步骤都被存储下来，典型用空间换取时间问题
使用动态规划所解决的问题要带有的性质：
        1.子问题重叠：当前问题与其子问题的计算方法相同
        2.子问题的最优解构成当前问题的最优解
由性质可得，每个子问题的最优解可以构成原问题的最优解
贪心算法和动态规划是解决问题的两种思路所体现的方法，各有优缺点，无好坏之分

问题举例：
1元，3元，5元如何凑出n元且使硬币数量最少的硬币个数。
        1)确定问题(我是谁)：凑够n元钱使用最少的硬币个数
        2)我从哪里来：由过去状态得到现在状态
        3)我要到哪里去：
d(1)表示n=1时情况   d(1)=1意为：要凑出1元钱，使用1枚硬币是最优解

d(2)表示n=2时，凑出两块钱的情况   
d(2)=d(2-1)+1(一个1元)=2  
意为：   要凑出2块钱，满足凑出2元钱的问题的最优子问题结果时(使用一枚硬币凑够一元钱)
        再额外使用一枚硬币所凑出2元钱的是最优解(使用最少枚硬币)

d(3)=min{d(3-3)+1=1}
        {d(3-1)+1=3}
d(3)=1

d(4)=min{d(4-3)+1=2}
        {d(4-1)+1=2}
d(3)=2

d(5)=min{d(5-5)+1=1}
        {d(5-3)+1=3}
        {d(5-1)+1=3}
d(5)=1

d(i)=min{d(i-v[j])+1}
i:n状态数
v[j]:1,3,5
j:0,1,2
无后效性：每个元素的使用只往前推得一步

状态：子问题的最优解
状态转移方程：有一个状态转变到另一个状态(通式)

0/1背包问题
如何向包中放宝石能得到最大价值
LIS问题求最长递增子序列

捡苹果
左上角出发只能向左或下两个方向移动
如何能够获得最多的苹果数量

LCS最长公共子序列，不要求有序，只要求。。














自顶向下：带备忘，从大数据往小存
自底向上：从小往大存(常用)



如何做出动态规划
①求状态
②求状态转移方程


动态规划用于求最优解
但所得结果不一定都是最优解
(更优数学方法)

典型使用空间换取时间方法


动态规划的几个经典问题

①凑钱问题(入门级)
(01背包问题)
有一个包有容量遇到宝石价值不同大小不同如何拿价值最高
假设有1.3.5圆硬币
要凑出n元钱
需要几枚硬币
自底向上
∴D()表凑够n元需硬币个数
D(1)=1(要凑够一元钱需要一元钱)
D(2)=D(2-1)+1
D(3)Ⅰ=D(3-3)+1【(目标三元减去已有面值三元)的硬币个数加上一个三元硬币的一个】
   Ⅱ=D(3-1)+1=3
  【ⅠⅡ取最小值】
D(4)ⅠD(4-3)+1=2
   Ⅱ

D(1)，D(3)，D(2)，D(4)均需存储上(空间换时间)
状态转移方程：有一个状态转变到另一个状态(通式)
所以通式为
D(i)=min{D(i-r[J])+1}
其中r[J]<=i



②求最长递增子序列(初级)
LIS：6，8，2，7，9，1，10，3
1)何为子序列
要求相对位置不变但不要求有序
举例： 8，9 可以；9，8不是
子数组/子串 要求有序的数组/字符串
2)方法
法①：穷举法
法②：
只往前看不往后看
D(0)=1(能跟自身之前元素构成最长递增子序列的元素个数)
下标为几的元素和自身之前元素能构成最长递增子序列的元素个数
D(1)=8>6  D(0)+1=2
       = 1

 

状态转移方程D(i)=max{D(j)+1,1}
v[j]<v[i]
0<=j<i
②的优化(一)
再开辟一个新数组(下标为长度)
从D(0)开始重新计算长度
W	X	1	3	9	10	 	 	 	 
 	0	1	2	3	4	5	6	7	8

不影响空间消耗，空间复杂度不变仍未O(n)
②的优化(二)
需要W数组时使用二分查找节省时间
