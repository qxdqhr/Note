

# 字符串查找:

- 在一个字符串(主串)中查找另一个字符串(匹配串)

## 字符串的最基本比较方法：

- 两串相同则向后走，不相同则均跳回串头

### 缺点:

- 极其消耗时间

## 举例:

```
abc abc e abc abc abcdabcabcfa
abc abc d abc abc f
aaa baa b abb aa
```

## 解决方法:KMP算法

- 用空间换取时间(较为广义的解决问题思路)
- KMP算法中要求主串不回跳

## 字符串的前缀和后缀

- 前缀串和后缀串均不包含原串的最后/最前的元素

### 前缀：

- 从前往后数n个元素的字符串

- 每个串可能含有原串1到n-1个元素
- 以当前串的开头为开头的字符串为当前串的前缀字符串

###  后缀：

- 从后往前数n个元素的字符串
- 每个串可能含有原串1到n-1个元素

### 前缀后缀最大匹配长度:

当前串的		前缀集合和后缀集合	的	交集	   中    最长的元素的	  长度

## 运行过程

- 先比较向后走遇到第一个不同的字符时,
- 表示此字符之前的字符串必定是完全相同的

- 









### Next数组:(核心)

- 存储所有子序列的前缀后缀匹配长度:

- 每一个对应位置存储当前串最大匹配长度的值，只跟当前匹配串有关系

- 当遇到出现最大匹配长度+1时,判断当前元素是否相同,相同则+1,后续以此类推

  

- 思想：

## 代码思路:

- 计算Next数组
  1. 申请一个等长数组malloc
  2. 令首元素为0
  3. 判断str[i]==str[next[i-1]]
     - 是	使next【i】=next【i-1】+1；相同加1
     - 否	判断next【i-1】是否为0		
       令next【i】=0			不同为0

- 匹配
  1. 判断两串是否相等
  2. 

当匹配串走到\0时匹配完成
用主串地址减去匹配串长度即为首次出现地址




