LV:
②Sunday算法---用来求一个字符串在另一个个字符串首次出现的首地址
KMP消耗空间---匹配串决定

开始比较先标记原始位置

要从右向左找：防止丢失存在该字符串但并未查出情况
步骤
异常判断（是否两个字符串均非空）
设定next数组
建立大小为256int大小的数组
并使用memset初始化（数组名，初始化的值，内存大小）为-1
使用循环将匹配串中所有元素被下标赋值
匹配
设定2个新的循环变量	j，k
循环1（两循环变量是否均小于各自字符串长度）
{	k=i【作用？】
循环2（	
两字符串此时字符是否相等--------检查字符串相等	
&&
  	i（主串循环变量），j（匹配串循环变量）的长度是否仍小于各自字符串-------
-------若两字符串完全相同时，在运行至结尾时能够正常结束循环
   ）
两循环变量i，j均向后移动
判断（j所在位置是否等于匹配串长度）
是
说明匹配串已到达自身的末尾，此时两字符串首次相等地址即为i-j（匹配完成）
否









RV
:Sunday
    比KMP简单
    存在主串和匹配串
    每次比较过字符后都标记主串中的对应字符
    出现首个不同字符时在主串中