# 冒泡排序

# Bubble Sort 冒泡排序

- 每进行一次a循环的意思是a循环中的循环变量+1

## 核心思想：

- 相邻两个元素进行大小比较，符合大小比较规则，交换元素位置

## 冒泡排序的特性：每次确定一个最值元素

1. 两层循环嵌套：
2. 内层循环：a-1-i次
3. 内层循环工作:从头至尾遍历，两两比较后交换
    1. **每次将无序序列中最大/小的元素放入有序序列（序列最后）**
4. 外层循环：a次
5. 外层循环工作:将所有无序序列中元素填入有序序列，为整个序列中元素数

## 求取内层循环的循环次数的过程：

- 外层每进行一次循环，无序序列中元素数量减1，
    - 序列有a个元素,依次全部比较需比较a-1次
- 第i轮内层循环中:
    - 序列中有a-i个元素，依次全部比较需要a-i-1次

# 冒泡排序的适用场合:

对有序数组排序冒泡执行最快,可以直接跳出

# 代码示例:

## 基础版本：

```
void BubbleSort(int a,int *arr){    int i=0;    int j=0;    for(i;i<a;i++)                  //外层循环    {        for(j;j<a-i-1;j++)          //内层循环        {            if(arr[j]>arr[j+1])     //比较大小，交换元素            {                arr[j]=arr[j]^arr[j+1];                arr[j+1]=arr[j]^arr[j+1];                arr[j]=arr[j]^arr[j+1]            }        }    }}
```

# 不同情况的优化

## 情况一：给定序列为有序序列

### 优化方法：

在交换元素值位置设置标记变量,标记变量显示 **无元素发生交换时** 不进入内层循环

```
void BubbleSort(int a,int *arr){        
int i=0;        int j=0;        int nflag=0;        //设定标记变量        for(i;i<a;i++)        {            for(j;j<a-i-1;j++)            {                if(arr[j]>arr[j+1])                {                    arr[j]=arr[j]^arr[j+1];                    arr[j+1]=arr[j]^arr[j+1];                    arr[j]=arr[j]^arr[j+1];                    nflag=1;        //一旦进入交换值区域将其置1                }            }        if(nflag==0)break;//整个序列进行一次循环后，未发生元素交换，原序列完全有序        }    }
```

## 情况二：序列为后半已经为有序序列 (最终优化)

```
2.7.14.3.19.70.80.90.102
```

- 此时，仅进行过一次外层循环，元素后半已经成为有序序列
- 将**上次最后发生交换的元素位置的前一位置**作为**本次要移动的元素位置**(将第一遍中的未变化的后半段序列不再比较)

### 推理过程:

- 已知:循环变量从0变化到3,一共走了[(3)-(0)+1]=4趟
    - 推理1:循环变量从0变化到a-2,一共走了[(a-2)-(0)+1]=a-1趟
    - 推理2:循环变量从i变化到a-2,一共走了[(a-2)-(i)+1]趟
- 设定F为剩余元素数,比较所有元素需要比较F-1趟
- 建立F与i之间的关系方程:
    
    ```
    [(a-2)-(i)+1]=F-1
    ```
    
    - 解得,i=a-F
    - 即可确定第(i+1)次循环中的下标位置(循环变量值)
    - 但在下次循环之前i会增加(++)–(i+1)
    - 这里在先减1,保证下次循环的位置正好是a-F
    
    ```
    void BubbleSort(int a,int *arr){    int i=0;    int j=0;    int nflag=0;    for(i;i<a;i++)//i为循环趟数    {        for(j;j<a-i-1;j++)//j为要比较的元素下标值        {//中间循环每次遍历到F处,遍历F-1趟            if(arr[j]>arr[j+1])            {                arr[j]=arr[j]^arr[j+1];                arr[j+1]=arr[j]^arr[j+1];                arr[j]=arr[j]^arr[j+1];                nflag=j+1;                //flag还能用于标记最大元素的移动位置            }        }    if(nflag==0)break;//所有元素走过一趟,压根没有元素进行交换    i=a-nflag-1；//每次更新下次移动位置为上一次循环中最后移动位置的前一位置(nflag-1)    }}
    ```
    

## 几种优化：

### 鸡尾酒排序：

- 冒泡排序的一种其他优化(效率提升不大)
- 第一遍从前向后找,第二遍从后向前找

### 快速排序:

- 见快速排序部分笔记

# 冒泡排序时间复杂度：

- 待排序序列一共有n个元素
    - 第1趟，n个元素时，比较次数是n-1次
    - 第2趟，n-1个元素时，比较次数是n-2次
- 完成一次完整的冒泡排序需要的次数为：
    
    ```
    n-1    +    n-2    +    n-3    +    ....    +   1
    ```
    
- 即等差数列 n-1，n-2，n-3….1 的 前项和
    
    S(n) = (a1+an)×n/2 = {[(n-1)+(1)]×n}/2 = 0.5*n2
    
- 所以冒泡排序的时间复杂度是O(n2);
    
    # 冒泡排序空间复杂度 :
    
    - 原地的交换 O(1)
    
    # 冒泡排序稳定性:
    
    - 稳定排序