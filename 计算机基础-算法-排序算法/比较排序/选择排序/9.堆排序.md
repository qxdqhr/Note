# 堆排序(HeapSort)

- 堆排序是选择排序的一种(选择出最值元素,移动至某一确定位置)

## 堆的概念:

- 堆不是二叉树，也无二叉树结构
- 逻辑上类似树形结构,实际以数组方式存储
- 对给定数组,以层序遍历二叉树的方式建立堆的逻辑结构

### 堆的分类:

- 大顶堆：
  - 任意父亲节点值都比其任意子节点值都大
  - 任意父亲节点的左右子节点无大小关系
- 小顶堆:
  - 任意父亲节点值都比其任意子节点值都大
  - 任意父亲节点的左右子节点无大小关系

## 建初始堆并调整:

1. 建立堆的逻辑结构;(层序遍历建立二叉树)
2. 确定调堆方向:
   1. 从下向上,从右往左;
   2. 所有父节点下标的范围:(n/2-1,0)
3. 判断父节点-子节点是否符合堆的要求(大顶堆/小顶堆)
   1. 不符合则交换父节点与对应子节点的位置
   2. 交换一组父子节点位置后,可能对其它已经建好的堆产生影响,再调整被影响的堆;
4. 当满足任意父亲节点值都比其任意子节点值都大的条件时,初始堆建立完毕

## 取出元素并不断调堆：

1. 取出初始堆中的堆顶元素(与最末尾元素交换)
2. 在堆中排除最末尾元素,此时堆中元素数减1,再次重新调堆
   1. 排除:将堆顶元素移至有序序列中,并将最末尾元素移至堆顶
3. 当整个堆再次平衡时,重复1,2操作
   1. 此时通过堆的性质可知,最多进行k-1次的比较就可以将堆调完
      1. k是堆的层数(完全二叉树的树高)
      2. 完全二叉树有n个节点,高度k=**⌊log<sub>2</sub>n⌋+1**
   2. 由此特点,极大地提高了原来选择排序的运行速度
4. 当堆中仅剩余1个元素时,即所有元素都被添加进入有序序列时,堆排序完成

## 注意:

- 堆的本质仍是一个数组,引用堆的结构是为了方便排序
- 与简单选择排序相比,堆排序采用二分思想进行比较元素
  - 仅进行k次比较(K为堆的层数)

## 代码思路:

### 1.建立初始堆:

1. 将整个数组中的每一个元素,按照完全二叉树的方式,相互连接

   ```
   			0	1	2	3	4	5	6
   ```

2. 数组下标与数内元素关系:

   1. 左子节点:2*当前节点下标+1
   2. 右子节点:2*当前节点下标+2

   ![image-20201108113615673](9.%E5%A0%86%E6%8E%92%E5%BA%8F.assets/image-20201108113615673.png)

### 2.开始排序:

#### 交换元素:

将首元素(对顶)与末尾元素进行交换

此时对顶已经为有序序列元素,可以不再关注

#### 开始调堆:

判断堆顶节点和其左右子节点大小关系

移动堆顶节点

判断移动后堆是否符合要求

直到当前节点再无子节点时结束

# TOP(K)问题:

- 给定一个序列,寻找此序列中最大的几个元素

## 解决方法:

### 1.暴力:

- 不断循环,每次循环得出一个最大的
- O(n^2^)

### 2.排序得出前几元素:

- 使用任意排序
- 依照排序而定

### 3.堆排序:

- 任意选取5个元素,建堆,取得最小值
- 继续取得序列中的其它元素
  - 若元素比最小值大,去除原最小值,寻找当前序列中的最小值(调堆)
  - 若元素比最小值小,继续向后遍历
- 使用堆来维护(需要不断调堆)
  - 找最大n个元素,使用小顶堆
  - 找最小n个元素,使用大顶堆
- 最终序列,仅需遍历一遍堆即可

### 









