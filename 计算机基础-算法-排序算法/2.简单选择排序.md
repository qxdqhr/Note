# 简单选择排序：

## 核心思想：

1. 遍历所有元素,每一趟寻找:
   1. 序列中的最小值放在序列的最前面 或者
   2. 序列中的最大值放在序列的最后面
2.  在无序序列中选择一个元素加入有序序列
     1. 此循环为趟数型循环所以要使用双层循环嵌套

### 具体工作:

1. 假设首元素为最大值,最值序列从最末尾元素开始;

#### 外层循环:

1. 遍历n-1个元素(需要先假设一个最值元素节点),直至无序序列全部转化为有序序列

#### 内层循环:

1. 记录最值元素的下标向后循环;
2. 循环时当前元素若比当前最大值元素还大,更新最大值元素的下标
3. 当一趟循环结束后,找到一个最值(的下标)
4. 将**最值元素**与**有序元素序列中的首元素位置**进行交换
   1. 有序序列首元素位置一般定为原序列最末尾元素(第n-1个元素)
   2. 第二次循环时,寻找第二大的元素,有序序列的第二个位置应该是下标为n-2的地方
      1. 有序序列位置以此类推
5. 交换完成后,一次内层循环结束

### 注意:

1. 比较最值有两种方法:
   1. 将有序序列放置在序列之后,每次向序列中添加最大的元素,交换位置范围为[n-1,0]
   2. 将有序序列放置在序列之前,每次像序列中添加最小的元素,交换位置范围为[0,n-1]

## 代码：

```c
void SelectSort(int a,int *arr)
{
	if(a<=0||arr==NULL) return; //异常参数判断
 	int minele;//最值元素,此处定为最小值
 	int i;//趟数变量
 	int j;//循环变量
 	for(i=0;i<a-1;i++)
 	//选取一个最值元素后序列中元素数-1,剩余n-1个,循环n-1次
 	{
 		minele=i;//记录好每一趟的初始下标
 		for(j=i+1;j<a;j++)  //寻找第i趟的最小值，仅记录最小值的下标
 		{
			if(arr[minele]>arr[j])//如果发现了更小的
 			{
 				minele=j;//更新下标
 			}
        }
        //交换元素至有序序列
 		if(minele!=i)       //判断最小值是否在其应在的位置
        {                   //如果要寻找最大值maxele应该与a-i比较，且交换的下标也应为a-i
 			arr[minele]=arr[minele]^arr[i];
 			arr[i]=arr[minele]^arr[i];
 			arr[minele]=arr[minele]^arr[i];
		}
	}
}
```

