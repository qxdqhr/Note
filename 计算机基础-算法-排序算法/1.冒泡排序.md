# Bubble Sort 冒泡排序    
- 每进行一次a循环的意思是a循环中的循环变量+1    

## 核心思想：
- 相邻两个元素进行大小比较，符合大小比较规则，交换元素位置

## 冒泡排序的特性：每次确定一个最值元素
1. 两层循环嵌套：
2. 内层循环：a-1-i次
3. 内层循环工作:从头至尾遍历，两两比较后交换
   1. **每次将无序序列中最大/小的元素放入有序序列（序列最后）**
4. 外层循环：a次
5. 外层循环工作:将所有无序序列中元素填入有序序列，为整个序列中元素数

## 求取内层循环的循环次数的过程：
- 外层每进行一次循环，无序序列中元素数量减1，
  - 序列有a个元素,依次全部比较需比较a-1次
- 第i轮内层循环中:
  - 序列中有a-i个元素，依次全部比较需要a-i-1次

# 代码示例:
## 基础版本：

```C
void BubbleSort(int a,int *arr)
{
    int i=0;
    int j=0;
    for(i;i<a;i++)                  //外层循环
    {
        for(j;j<a-i-1;j++)          //内层循环
        {
            if(arr[j]>arr[j+1])     //比较大小，交换元素
            {   
                arr[j]=arr[j]^arr[j+1]; 
                arr[j+1]=arr[j]^arr[j+1];
                arr[j]=arr[j]^arr[j+1]
            }
        }
    }
}
```

# 不同情况的优化
## 情况一：给定序列为有序序列
### 优化方法：
在交换元素值位置设置标记变量,标记变量显示 **无元素发生交换时** 不进入内层循环
        
```C
    void BubbleSort(int a,int *arr)
    {
        int i=0;
        int j=0;
        int nflag=0;        //设定标记变量 
        for(i;i<a;i++)
        {
            for(j;j<a-i-1;j++)
            {
                if(arr[j]>arr[j+1])
                {   
                    arr[j]=arr[j]^arr[j+1];
                    arr[j+1]=arr[j]^arr[j+1];
                    arr[j]=arr[j]^arr[j+1];
                    nflag=1;        //一旦进入交换值区域将其置1
                }
            }
        if(nflag==0)break;//整个序列进行一次循环后，未发生元素交换，原序列完全有序
        }
    }
```
## 情况二：序列为后半已经为有序序列  

    2.7.14.3.19.70.80.90.102

- 此时，仅进行过一次外层循环，元素后半已经成为有序序列
- 为节省步骤，将上次最后移动的元素位置的前一位置作为接下来要移动的元素位置
- i=n-1，从0到n-2

    ```C
    void BubbleSort(int a,int *arr)
    {
        int i=0;
        int j=0;
        int nflag=0;
        for(i;i<a;i++)//i为循环趟数
        {
            for(j;j<a-i-1;j++)//j为要比较的元素下标值
            {
                if(arr[j]>arr[j+1])
                {   
                    arr[j]=arr[j]^arr[j+1];
                    arr[j+1]=arr[j]^arr[j+1];
                    arr[j]=arr[j]^arr[j+1];
                    nflag=j+1;
                }
            }
        if(nflag==0)break;
        i=a-nflag-1；//每次更新下次移动位置为上一次循环中最后移动位置的前一位置
        }
    }
    ```

## 几种优化：

### 鸡尾酒排序：

- 冒泡排序的一种其他优化(效率提升不大)
- 第一遍从前向后找,第二遍从后向前找   

### 快速排序:

- 见快速排序部分笔记

# 冒泡排序时间复杂度：

- 待排序序列一共有n个元素

  - 第1趟，n个元素时，比较次数是n-1次
  - 第2趟，n-1个元素时，比较次数是n-2次

- 完成一次完整的冒泡排序需要的次数为：
      

  ```
  n-1    +    n-2    +    n-3    +    ....    +   1
  ```

- 即等差数列  n-1，n-2，n-3....1  的 前项和    
  
  S(n)	=	(a1+an)×n/2
  			=	{[(n-1)+(1)]×n}/2
  			=	0.5*n^2^
  
- 所以冒泡排序的时间复杂度是O(n^2^);

  

​    
