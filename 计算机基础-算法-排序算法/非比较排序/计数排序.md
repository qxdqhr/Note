# Count_Sort:纯数据的计数排序

- 计数排序是基于**非比较性排序**
- 通过计算每个元素的出现次数进行排序

## 适用范围：

- 要求序列中各元素值分配较为密集
- 相同数据元素值出现频率较高

## 基本过程：

1. 找序列中的最大值最小值确定区间
2. 申请长度为n的计数数组                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           
   - 计数数组的长度由区间确定
   - 计数数组的长度=最大值-最小值
3. 向计数器中数组添加每个数字的出现次数
   1. 每次增加对应元素个数时,计数数组的对应下标值=序列中元素值-序列最小值 
4. 由计数器数组更新原数组
   1. 遍历整个计数数组,每次遍历中:
      - 打印元素值=计数数组下标值+序列最小值
      - 每遍历一次,计数数组中的对应值减1,到0时退出
5. 回收计数器空间                                                          

## 注意：
1. 计数排序只能应用于简单序列排序
   - 排序后的数组中元素**不是原数组中的元素**，**是复制出来的相同元素**

```
 void CountSort(int nLength,int *arr)
 {
 	//确定序列中的最大值和最小值
 	int i=0;
    int maxele=arr[0];//设定最大最小值初值为序列中首元素
    int minele=arr[0];
	for(int i=0;i<nLength;i++)
    {
         if(arr[i]<minele)   minele=arr[i];
         if(arr[i]>maxele)   maxele=arr[i];
 	}
 	//开辟计数数组空间
 	int *pCount=(int*)malloc((maxele-minele+1)*sizeof(int));
 	memset(pCount,0,sizeof(int)*(maxele-minele+1));
 	//填充计数数组
 	for(int i=0;i<nLength;i++)
 	{
 		pCount[arr[i]-minele]++;
 		//数组下标+序列最小值=原序列元素值
 	}
 	//放回原数组
 	int j=0;//遍历原数组变量
 	for(int i=0;i<maxele-minele+1;i++)
 	{
 		while(pCount[i]!=0)
 		{
 			arr[j]=i+minele;//数组下标+序列最小值=原序列元素值
 			j++;//原数组中放入一个元素后即向后移动
 			pCount[i]--;//计数数组中的对应出现次数减少			
 		}
 	}
 	//释放
 	free(pCount);
 	pCount=NULL;
 }
```

## 计数排序的优化

### 优化方案1:

#### 基本过程：

##### 创建计数数组:

1. 找序列中的最大值最小值确定区间
2. 申请一个计数器（由区间确定的计数数组）
3. 为计数数组赋值

##### 累加计数数组:

1. 从计数数组中的首元素开始不断更新首元素后的元素值
2. 依照**后一元素=前一元素+当前数组元素值**的原则进行更新计数数组
   1. 此时,计数数组中存储的值表示对应值(计数数组下标)在有序序列中出现的最后的位置(下标+1)
3. 从后向前遍历原数组,通过计数数组确定有序序列
   1. 从头遍历计数数组
   2. 当前无序元素 == 计数数组下标+最小值元素--对-应--计数数组元素 == 有序序列中的下标+1
   3. 将当前无序元素赋值入对应有序序列的下标值
   4. 遍历后令计数数组元素减1
   5. 向前遍历无序元素
4. 回收计数器

